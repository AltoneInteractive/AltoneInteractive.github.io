<!DOCTYPE html>
<html lang="en" class="dark-mode">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ichrolic Translator</title>
  <style>
    :root {
      --bg-color: #f5f5f5;
      --container-bg: white;
      --text-color: #333;
      --heading-color: #3a506b;
      --border-color: #ccc;
      --button-bg: #3a506b;
      --button-text: white;
      --button-hover: #1c2541;
      --settings-bg: #f9f9f9;
      --table-header-bg: #f2f2f2;
      --table-border: #ddd;
      --table-hover: #f9f9f9;
      --synonym-row-bg: #f0f8ff;
      --synonym-row-hover: #e6f2ff;
      --box-shadow: rgba(0, 0, 0, 0.1);
    }

    html.dark-mode {
      --bg-color: #1e1e1e;
      --container-bg: #2d2d2d;
      --text-color: #e0e0e0;
      --heading-color: #7dbe90;
      --border-color: #444;
      --button-bg: #7dbe90;
      --button-text: #193b27;
      --button-hover: #7dbe90;
      --settings-bg: #383838;
      --table-header-bg: #3b4252;
      --table-border: #555;
      --table-hover: #3b4252;
      --synonym-row-bg: #2c303f;
      --synonym-row-hover: #434c5e;
      --box-shadow: rgba(0, 0, 0, 0.3);
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      padding: 20px;
      max-width: 900px;
      margin: 0 auto;
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    .container {
      background-color: var(--container-bg);
      border-radius: 10px;
      box-shadow: 0 4px 8px var(--box-shadow);
      padding: 20px;
      position: relative;
    }

    /* Developer mode dropdown styles */
    .dev-menu {
      position: absolute;
      top: 20px;
      left: 20px;
      display: none;
    }

    .dev-menu.show {
      display: block;
    }

    .dev-menu-toggle {
      background-color: var(--button-bg);
      color: var(--button-text);
      border: none;
      padding: 8px 12px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 18px;
      line-height: 1;
    }

    .dev-menu-toggle.dev-mode {
      background-color: #808080;
      color: white;
    }

    .dev-menu-toggle:hover {
      background-color: var(--button-hover);
    }

    .dev-menu-toggle.dev-mode:hover {
      background-color: #696969;
    }

    .dev-menu-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      margin-top: 5px;
      background-color: var(--container-bg);
      border: 1px solid var(--border-color);
      border-radius: 5px;
      box-shadow: 0 4px 8px var(--box-shadow);
      min-width: 160px;
      z-index: 1000;
      display: none;
    }

    .dev-menu-dropdown.show {
      display: block;
    }

    .dev-menu-item {
      padding: 10px 15px;
      cursor: pointer;
      border-bottom: 1px solid var(--border-color);
      transition: background-color 0.2s ease;
      white-space: nowrap;
    }

    .dev-menu-item:last-child {
      border-bottom: none;
    }

    .dev-menu-item:hover {
      background-color: var(--table-hover);
    }

    /* Sign-in modal styles */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }

    .modal-overlay.show {
      display: flex;
    }

    .modal {
      background-color: var(--container-bg);
      border-radius: 10px;
      box-shadow: 0 8px 16px var(--box-shadow);
      padding: 30px;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
    }

    .modal h2 {
      color: var(--heading-color);
      margin-bottom: 20px;
      text-align: center;
    }

    .modal p {
      margin-bottom: 15px;
      line-height: 1.5;
    }

    .modal input {
      width: 100%;
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: 5px;
      margin-bottom: 15px;
      font-family: inherit;
      background-color: var(--container-bg) !important;
      color: var(--text-color) !important;
      -webkit-text-fill-color: var(--text-color);
    }

    .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }

    .modal-buttons button {
      padding: 10px 20px;
    }

    .modal a {
      color: var(--heading-color);
      text-decoration: none;
    }

    .modal a:hover {
      text-decoration: underline;
    }

    .cancel-button {
      background-color: #6c757d;
      color: white;
    }

    .cancel-button:hover {
      background-color: #5a6268;
    }

    /* Loading state for buttons */
    .loading {
      opacity: 0.6;
      cursor: not-allowed;
      position: relative;
    }

    .loading:after {
      content: '';
      position: absolute;
      width: 16px;
      height: 16px;
      margin: auto;
      border: 2px solid transparent;
      border-top-color: currentColor;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    @keyframes spin {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }

    /* Signed in indicator */
    .signed-in-indicator {
      color: #28a745;
      font-size: 12px;
    }

    /* Goldenrod button style for developer mode */
    .goldenrod-button {
      background-color: #DAA520 !important;
      color: #8B4513 !important;
    }

    .goldenrod-button:hover {
      background-color: #B8860B !important;
    }
    h1 {
      color: var(--heading-color);
      text-align: center;
      margin-bottom: 30px;
      transition: margin-left 0.3s ease;
    }

    /* Only apply dev mode margin on mobile/smaller screens */
    @media (max-width: 768px) {
      h1.dev-mode {
        margin-left: 60px; /* Make room for dev menu only in dev mode on mobile */
      }
    }
    .translator {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .text-areas {
      display: flex;
      gap: 20px;
    }
    @media (max-width: 768px) {
      .text-areas {
        flex-direction: column;
      }
    }
    .text-column {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    .header {
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    /* Click to copy header styling */
    .copy-header {
      font-size: 0.85em;
      color: #666;
    }
    
    html.dark-mode .copy-header {
      color: #999;
    }
    /* Complete text area styling with focus states */
    textarea, .english-input-editor {
      height: 200px;
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: 5px;
      resize: none;
      font-size: 16px;
      font-family: inherit;
      background-color: var(--container-bg) !important;
      color: var(--text-color) !important; /* Force text color */
      transition: border-color 0.2s ease, outline-color 0.2s ease;
      -webkit-text-fill-color: var(--text-color); /* For WebKit browsers */
    }

    .english-input-editor {
      overflow-y: auto;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    /* Reset any inherited text decoration for regular text (but not variant words) */
    .english-input-editor {
      text-decoration: none !important;
    }

    .english-input-editor:empty:before {
      content: "Enter English text here...";
      color: #999;
      pointer-events: none;
    }

    textarea:focus, .english-input-editor:focus {
      background-color: var(--container-bg) !important; /* Force override */
      color: var(--text-color) !important; /* Force override */
      border-color: var(--heading-color);
      outline: 1px solid var(--heading-color);
      outline-offset: -1px; /* Keep outline tight to the border */
      -webkit-text-fill-color: var(--text-color); /* For WebKit browsers */
    }

    /* For webkit browsers like Chrome/Safari */
    textarea:focus-visible, .english-input-editor:focus-visible {
      background-color: var(--container-bg) !important;
      color: var(--text-color) !important;
      -webkit-text-fill-color: var(--text-color);
    }
    
    /* Fix for Firefox */
    textarea:-moz-ui-invalid {
      box-shadow: none;
    }
    
    /* Force text color for all input states */
    textarea:active, textarea:hover, textarea:focus,
    .english-input-editor:active, .english-input-editor:hover, .english-input-editor:focus {
      color: var(--text-color) !important;
    }

    /* Variant word styling */
    .english-input-editor .variant-word {
      text-decoration: underline !important;
      text-decoration-style: dashed !important;
      text-decoration-color: var(--heading-color) !important;
      cursor: pointer;
      position: relative;
    }

    .english-input-editor .variant-word:hover {
      background-color: var(--table-hover);
      border-radius: 2px;
    }

    /* Special styling for the Ichrolic output textarea */
    #ichrolicOutput {
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      position: relative;
      transition: all 0.2s ease;
    }

    #ichrolicOutput:hover {
      background-color: var(--table-hover) !important;
      border-color: var(--heading-color);
    }

    /* Copy feedback styling */
    .copy-feedback {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: var(--heading-color);
      color: var(--button-text);
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: bold;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 100;
    }

    .copy-feedback.show {
      opacity: 1;
    }

    /* Custom tooltip styles */
    .tooltip-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 1000;
    }

    .custom-tooltip {
      position: absolute;
      visibility: hidden;
      background-color: var(--text-color);
      color: var(--container-bg);
      text-align: center;
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 12px;
      font-weight: bold;
      white-space: nowrap;
      z-index: 1001;
      box-shadow: 0 2px 8px var(--box-shadow);
      transition: opacity 0.1s ease;
      opacity: 0;
    }

    .custom-tooltip.show {
      visibility: visible;
      opacity: 1;
    }

    /* Arrow pointing up to the word */
    .custom-tooltip::before {
      content: "";
      position: absolute;
      top: -5px;
      left: 50%;
      margin-left: -5px;
      border-width: 0 5px 5px 5px;
      border-style: solid;
      border-color: transparent transparent var(--text-color) transparent;
    }

    .settings {
      background-color: var(--settings-bg);
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
    }
    .settings-header {
      font-weight: bold;
      margin-bottom: 10px;
    }
    .settings-grid {
      display: grid;
      grid-template-rows: repeat(2, 1fr);
      grid-auto-flow: column;
      grid-auto-columns: max-content;
      gap: 10px 20px;
    }
    .setting {
      display: flex;
      align-items: center;
    }
    .setting label {
      margin-left: 8px;
    }
    
    /* Dev-only settings */
    .dev-only-setting {
      display: none;
    }
    
    .dev-mode .dev-only-setting {
      display: flex;
    }
    .dictionary-controls {
      margin-top: 20px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .dictionary-status {
      margin-top: 10px;
      font-style: italic;
      color: #666;
    }
    html.dark-mode .dictionary-status {
      color: #aaa;
    }
    .add-entry #synonymToggle {
      padding: 5px 10px;
      background-color: #6c757d;
      min-width: 40px;
    }
    button {
      background-color: var(--button-bg);
      color: var(--button-text);
      border: none;
      padding: 8px 15px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover {
      background-color: var(--button-hover);
    }
    .dictionary-table {
      margin-top: 20px;
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid var(--table-border);
      border-radius: 5px;
    }
    .dictionary-search {
      margin-bottom: 15px;
      width: 100%;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .dictionary-search input {
      flex: 1;
      padding: 8px;
      border: 1px solid var(--border-color);
      border-radius: 5px;
      background-color: var(--container-bg) !important;
      color: var(--text-color) !important;
      -webkit-text-fill-color: var(--text-color);
    }
    
    /* Fix for all input elements */
    input[type="text"] {
      background-color: var(--container-bg) !important;
      color: var(--text-color) !important;
      -webkit-text-fill-color: var(--text-color);
    }
    
    input[type="text"]:focus, input[type="text"]:active, input[type="text"]:hover {
      background-color: var(--container-bg) !important;
      color: var(--text-color) !important;
      -webkit-text-fill-color: var(--text-color);
    }
    .dictionary-search .setting {
      margin-bottom: 0;
      white-space: nowrap;
      padding-right: 8px;
    }
    .dictionary-fixed-header {
      position: sticky;
      top: 0;
      background-color: var(--container-bg);
      padding: 15px 0;
      z-index: 10;
      border-bottom: 1px solid var(--border-color);
    }
    
    /* Mobile-friendly table styles */
    .table-responsive {
      overflow-x: auto;
      width: 100%;
    }
    
    @media (max-width: 768px) {
      .table-container {
        margin: 0 -15px; /* Negative margin to allow full-width scrolling */
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
      }
      
      .mobile-table {
        display: flex;
        flex-direction: column;
        margin-top: 15px;
      }
      
      .mobile-table-entry {
        border: 1px solid var(--table-border);
        border-radius: 5px;
        margin-bottom: 10px;
        padding: 10px;
        background-color: var(--container-bg);
      }
      
      .mobile-table-entry.synonym-row {
        background-color: var(--synonym-row-bg);
      }
      
      .mobile-table-row {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5px;
        flex-wrap: wrap;
      }
      
      .mobile-table-label {
        font-weight: bold;
        margin-right: 10px;
        min-width: 70px;
      }
      
      .mobile-table-actions {
        display: flex;
        gap: 5px;
        margin-top: 10px;
        flex-wrap: wrap;
      }
    }
    
    /* Regular table for larger screens */
    @media (min-width: 769px) {
      table {
        width: 100%;
        border-collapse: collapse;
      }
      th, td {
        padding: 8px 12px;
        text-align: left;
        border-bottom: 1px solid var(--table-border);
      }
      th {
        background-color: var(--table-header-bg);
        color: var(--text-color);
        position: sticky;
        top: 0;
      }
      tr:hover {
        background-color: var(--table-hover);
      }
      tr.synonym-row {
        background-color: var(--synonym-row-bg);
      }
      tr.synonym-row:hover {
        background-color: var(--synonym-row-hover);
      }
      .mobile-table {
        display: none;
      }
    }
    
    .add-entry {
      margin-top: 20px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .add-entry input {
      flex: 1;
      padding: 8px;
      border: 1px solid var(--border-color);
      border-radius: 5px;
      background-color: var(--container-bg) !important;
      color: var(--text-color) !important;
      -webkit-text-fill-color: var(--text-color);
    }
    .empty-dictionary {
      padding: 20px;
      text-align: center;
      color: #666;
      font-style: italic;
    }
    html.dark-mode .empty-dictionary {
      color: #aaa;
    }
    .sort-indicator {
      display: inline-block;
    }
    
    /* Dark mode toggle styles */
    .dark-mode-toggle {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    @media (max-width: 422px) {
      .dark-mode-toggle {
        top: 15px;
        right: 15px;
      }
      
      .mode-toggle-emoji {
        cursor: pointer;
        font-size: 24px;
        line-height: 1;
        display: block;
      }
      
      .toggle-switch, .mode-icon {
        display: none !important;
      }
    }
    
    @media (min-width: 423px) {
      .mode-toggle-emoji {
        display: none;
      }
    }
    
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 30px;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 34px;
    }
    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 22px;
      width: 22px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    input:checked + .toggle-slider {
      background-color: #7dbe90;
    }
    input:checked + .toggle-slider:before {
      transform: translateX(30px);
    }
    .mode-icon {
      font-size: 20px;
    }
    
    /* Mobile title and layout improvements */
    @media (max-width: 768px) {
      h1 {
        text-align: left;
        font-size: 1.5rem; /* Smaller size on mobile */
        margin-bottom: 10px;
        margin-right: 10px; /* Make space for the toggle switch */
      }

      .dark-mode-toggle {
        top: 30px; /* Align with the title */
      }

      .container {
        padding: 15px; /* Slightly reduce padding on mobile */
      }
      
      .dictionary-controls {
        justify-content: space-between;
      }
      
      .dictionary-controls button {
        flex-grow: 1;
        text-align: center;
      }
      
      .add-entry {
        flex-direction: column;
      }
      
      .add-entry input {
        width: 100%;
      }
      
      #synonymToggle {
        align-self: flex-start;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Developer mode menu -->
    <div class="dev-menu" id="devMenu">
      <button class="dev-menu-toggle" id="devMenuToggle">⋯</button>
      <div class="dev-menu-dropdown" id="devMenuDropdown">
        <div class="dev-menu-item" id="devSignIn">
          <span id="signInText">Sign In</span>
        </div>
        <div class="dev-menu-item" id="devClose">Reset</div>
      </div>
    </div>

    <!-- Sign-in modal -->
    <div class="modal-overlay" id="signInModal">
      <div class="modal">
        <h2>Developer Sign In</h2>
        <p>Enter your GitHub Personal Access Token to enable dictionary updates.</p>
        <p><strong>Required permissions:</strong> Contents, Metadata</p>
        <p><a href="https://github.com/settings/tokens/new?scopes=repo" target="_blank">Create a new token →</a></p>
        <input type="password" id="tokenInput" placeholder="ghp_xxxxxxxxxxxxxxxxxxxx" />
        <div class="modal-buttons">
          <button class="cancel-button" id="cancelSignIn">Cancel</button>
          <button id="confirmSignIn">Sign In</button>
        </div>
      </div>
    </div>

    <h1 id="pageTitle">Ichrolic Translator</h1>

    <div class="dark-mode-toggle">
      <span class="mode-icon">☀️</span>
      <label class="toggle-switch">
        <input type="checkbox" id="darkModeToggle" checked>
        <span class="toggle-slider"></span>
      </label>
      <span class="mode-icon">🌙</span>
      <!-- Added emoji toggle for smaller screens -->
      <span class="mode-toggle-emoji" id="modeToggleEmoji">🌙</span>
    </div>

    <div class="settings">
      <div class="settings-header">Settings</div>
      <div class="settings-grid">
        <div class="setting">
          <input type="checkbox" id="ignoreDiacritics">
          <label for="ignoreDiacritics">Ignore Diacritics</label>
        </div>
        <div class="setting">
          <input type="checkbox" id="useContractions" checked>
          <label for="useContractions">Use Contractions</label>
        </div>
        <div class="setting dev-only-setting">
          <input type="checkbox" id="forceSync">
          <label for="forceSync">Force Sync</label>
        </div>
      </div>
    </div>

    <div class="translator">
      <div class="text-areas">
        <div class="text-column">
          <div class="header">English</div>
          <div style="position: relative;">
            <div id="englishInput" class="english-input-editor" contenteditable="true"></div>
            <!-- Tooltip overlay positioned above the text area -->
            <div id="tooltipOverlay" class="tooltip-overlay">
              <div id="customTooltip" class="custom-tooltip">
                <span id="tooltipText"></span>
              </div>
            </div>
          </div>
        </div>
        <div class="text-column" style="position: relative;">
          <div class="header">Ichrolic <span class="copy-header">(Click to Copy)</span></div>
          <textarea id="ichrolicOutput" placeholder="Ichrolic translation will appear here..." readonly title="Click to copy to clipboard"></textarea>
          <div class="copy-feedback" id="copyFeedback">Copied! ✓</div>
        </div>
      </div>
    </div>

    <div class="dictionary-controls">
      <button id="saveDictionary">Save Dictionary</button>
      <button id="showDictionary">Show/Hide Dictionary</button>
    </div>
    <div class="dictionary-status" id="dictionaryStatus"></div>

    <div class="dictionary-table" id="dictionaryTable" style="display: none;">
      <div class="dictionary-search">
        <input type="text" id="dictionarySearchInput" placeholder="Search dictionary...">
        <div class="setting">
          <input type="checkbox" id="showSynonyms" checked>
          <label for="showSynonyms">Show Synonyms</label>
        </div>
      </div>

      <div class="add-entry">
        <input type="text" id="newEnglish" placeholder="English word or phrase">
        <button id="synonymToggle" title="Toggle between direct translation and synonym">=</button>
        <input type="text" id="newIchrolic" placeholder="Ichrolic translation">
        <button id="addEntry">Add Entry</button>
      </div>

      <!-- Regular table for desktop view -->
      <div class="table-container">
        <table id="desktopTable">
          <thead>
            <tr>
              <th id="englishHeader">English</th>
              <th id="ichrolicHeader">Ichrolic</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="dictionaryBody">
            <!-- Dictionary entries will be added here -->
          </tbody>
        </table>
      </div>
      
      <!-- Mobile-friendly table layout -->
      <div class="mobile-table" id="mobileTable">
        <!-- Mobile entries will be added here -->
      </div>

      <div id="emptyDictionary" class="empty-dictionary">
        No dictionary entries yet. Add some above!
      </div>
    </div>
  </div>

  <script>
    // Dark mode functionality
    const darkModeToggle = document.getElementById('darkModeToggle');
    const modeToggleEmoji = document.getElementById('modeToggleEmoji');
    const htmlElement = document.documentElement;

    // Function to toggle dark mode
    function toggleDarkMode() {
      htmlElement.classList.toggle('dark-mode');
      localStorage.setItem('darkMode', htmlElement.classList.contains('dark-mode'));
      
      // Update the emoji for small screens
      if (htmlElement.classList.contains('dark-mode')) {
        modeToggleEmoji.textContent = '🌙';
      } else {
        modeToggleEmoji.textContent = '☀️';
      }
    }

    // Event listener for the toggle switch
    darkModeToggle.addEventListener('change', toggleDarkMode);
    
    // Event listener for the emoji toggle (for mobile)
    modeToggleEmoji.addEventListener('click', function() {
      darkModeToggle.checked = !darkModeToggle.checked;
      toggleDarkMode();
    });

    // Set initial state (dark mode by default)
    // We've already added the 'dark-mode' class to the html element

    // Main dictionary and synonyms objects
    let dictionary = {};
    let synonyms = {};

    // DOM Elements
    const synonymToggleButton = document.getElementById('synonymToggle');
    const englishInput = document.getElementById('englishInput');
    const ichrolicOutput = document.getElementById('ichrolicOutput');
    const ignoreDiacriticsCheckbox = document.getElementById('ignoreDiacritics');
    const useContractionsCheckbox = document.getElementById('useContractions');
    const forceSyncCheckbox = document.getElementById('forceSync');
    const saveDictionaryButton = document.getElementById('saveDictionary');
    const showDictionaryButton = document.getElementById('showDictionary');
    const dictionaryStatus = document.getElementById('dictionaryStatus');
    const dictionaryTable = document.getElementById('dictionaryTable');
    const dictionaryBody = document.getElementById('dictionaryBody');
    const mobileTable = document.getElementById('mobileTable');
    const newEnglishInput = document.getElementById('newEnglish');
    const newIchrolicInput = document.getElementById('newIchrolic');
    const addEntryButton = document.getElementById('addEntry');
    const dictionarySearchInput = document.getElementById('dictionarySearchInput');
    const showSynonymsCheckbox = document.getElementById('showSynonyms');
    const englishHeader = document.getElementById('englishHeader');
    const ichrolicHeader = document.getElementById('ichrolicHeader');
    const copyFeedback = document.getElementById('copyFeedback');

    // Developer mode elements
    const pageTitle = document.getElementById('pageTitle');
    const devMenu = document.getElementById('devMenu');
    const devMenuToggle = document.getElementById('devMenuToggle');
    const devMenuDropdown = document.getElementById('devMenuDropdown');
    const devSignIn = document.getElementById('devSignIn');
    const devClose = document.getElementById('devClose');
    const signInText = document.getElementById('signInText');
    const signedInIndicator = document.getElementById('signedInIndicator');
    const signInModal = document.getElementById('signInModal');
    const tokenInput = document.getElementById('tokenInput');
    const confirmSignIn = document.getElementById('confirmSignIn');
    const cancelSignIn = document.getElementById('cancelSignIn');

    let isSynonymMode = false; // Track the current mode
    let isDeveloperMode = false; // Track developer mode
    let githubToken = localStorage.getItem('github_token'); // GitHub token
    let currentUser = null; // Store user info

    // Variant tracking system
    let wordVariants = {}; // Maps base words to their variants
    let selectedVariants = {}; // Maps base words to currently selected variant

    // Build variant mapping from dictionary
    function buildVariantMapping() {
      wordVariants = {};
      
      // Find all dictionary keys with variants (containing "/")
      for (const key in dictionary) {
        if (key.includes('/')) {
          const [baseWord, variantType] = key.split('/');
          if (!wordVariants[baseWord]) {
            wordVariants[baseWord] = [];
          }
          wordVariants[baseWord].push({
            key: key,
            type: variantType.toUpperCase(),
            translation: dictionary[key]
          });
        }
      }
      
      // Sort variants alphabetically by type for consistent ordering
      for (const baseWord in wordVariants) {
        wordVariants[baseWord].sort((a, b) => a.type.localeCompare(b.type));
        // Set default selection to first variant
        if (!selectedVariants[baseWord]) {
          selectedVariants[baseWord] = 0;
        }
      }
      
      console.log('Built variants:', Object.keys(wordVariants));
    }

    // Get the currently selected variant for a word
    function getSelectedVariant(baseWord) {
      if (!wordVariants[baseWord]) return null;
      const variantIndex = selectedVariants[baseWord] || 0;
      return wordVariants[baseWord][variantIndex];
    }

    // Cycle to next variant for a word
    function cycleVariant(baseWord) {
      if (!wordVariants[baseWord]) return;
      const currentIndex = selectedVariants[baseWord] || 0;
      const nextIndex = (currentIndex + 1) % wordVariants[baseWord].length;
      selectedVariants[baseWord] = nextIndex;
      
      const newVariant = wordVariants[baseWord][nextIndex];
      console.log(`Cycled "${baseWord}" to variant: ${newVariant.type} (${newVariant.translation})`);
      
      // Update tooltip immediately if this word is currently being hovered
      updateCurrentTooltip();
      
      // Update display and retranslate
      updateEnglishInputDisplay();
      translateToIchrolic();
    }

    // HTML escape function to prevent XSS
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Update the English input display with variant markup
    function updateEnglishInputDisplay() {
      const fullText = getPlainTextFromInput();
      const text = fullText.trim();
      if (!text) {
        // If no text, completely clear and reset
        englishInput.innerHTML = '';
        return;
      }

      // Check if we actually have any variant words to mark
      const hasVariants = text.split(/\s+/).some(word => {
        const cleanWord = word.toLowerCase().replace(/[.,!?;:]/g, '');
        return wordVariants[cleanWord];
      });
      
      if (!hasVariants) {
        // No variants to mark, ensure we have clean plain text
        if (englishInput.innerHTML !== fullText) {
          const selection = window.getSelection();
          let cursorTextOffset = 0;
          
          if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            cursorTextOffset = getAbsoluteTextOffset(englishInput, range.startContainer, range.startOffset);
          }
          
          englishInput.innerHTML = '';
          englishInput.textContent = fullText;
          restoreCursorToTextOffset(englishInput, cursorTextOffset);
        }
        return;
      }

      // Save cursor position as absolute text offset (ignoring HTML)
      const selection = window.getSelection();
      let cursorTextOffset = 0;
      
      if (selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        cursorTextOffset = getAbsoluteTextOffset(englishInput, range.startContainer, range.startOffset);
      }

      // Tokenize the FULL text (including trailing spaces) while preserving spaces and punctuation
      const tokens = [];
      let currentWord = "";
      const punctuationChars = [",", ".", "!", "?", ";", ":"];

      for (const c of fullText) {
        if (c === " ") {
          if (currentWord !== "") {
            tokens.push({ type: 'word', content: currentWord });
            currentWord = "";
          }
          tokens.push({ type: 'space', content: " " });
        } else if (punctuationChars.includes(c)) {
          if (currentWord !== "") {
            tokens.push({ type: 'word', content: currentWord });
            currentWord = "";
          }
          tokens.push({ type: 'punctuation', content: c });
        } else {
          currentWord += c;
        }
      }

      if (currentWord !== "") {
        tokens.push({ type: 'word', content: currentWord });
      }

      // Build HTML with variant markup - SECURE VERSION
      let html = "";
      for (const token of tokens) {
        if (token.type === 'word') {
          const baseWord = token.content.toLowerCase();
          if (wordVariants[baseWord]) {
            const escapedBaseWord = escapeHtml(baseWord);
            const escapedContent = escapeHtml(token.content);
            html += `<span class="variant-word" data-base-word="${escapedBaseWord}">${escapedContent}</span>`;
          } else {
            html += escapeHtml(token.content);
          }
        } else {
          html += escapeHtml(token.content);
        }
      }

      // Update the content
      englishInput.innerHTML = html;

      // Add event listeners for custom tooltips
      setupTooltipHandlers();

      // Restore cursor position using absolute text offset
      restoreCursorToTextOffset(englishInput, cursorTextOffset);
    }

    // Custom tooltip system
    const tooltipOverlay = document.getElementById('tooltipOverlay');
    const customTooltip = document.getElementById('customTooltip');
    const tooltipText = document.getElementById('tooltipText');
    let currentTooltipWord = null;

    function setupTooltipHandlers() {
      const variantWords = englishInput.querySelectorAll('.variant-word');
      
      variantWords.forEach(word => {
        word.addEventListener('mouseenter', showTooltip);
        word.addEventListener('mouseleave', hideTooltip);
        word.addEventListener('click', handleVariantClick);
      });
    }

    function handleVariantClick(e) {
      e.preventDefault();
      e.stopPropagation();
      const baseWord = e.target.getAttribute('data-base-word');
      if (baseWord) {
        cycleVariant(baseWord);
      }
    }

    function showTooltip(e) {
      const variantWord = e.target;
      const baseWord = variantWord.getAttribute('data-base-word');
      if (!baseWord) return;

      currentTooltipWord = baseWord;
      updateTooltipContent(baseWord);
      positionTooltip(variantWord);
      customTooltip.classList.add('show');
    }

    function hideTooltip() {
      currentTooltipWord = null;
      customTooltip.classList.remove('show');
    }

    function updateTooltipContent(baseWord) {
      const variant = getSelectedVariant(baseWord);
      const text = variant ? variant.type : 'VARIANT';
      tooltipText.textContent = text;
    }

    function positionTooltip(targetElement) {
      const inputRect = englishInput.getBoundingClientRect();
      const targetRect = targetElement.getBoundingClientRect();
      
      // Calculate position relative to the input container
      const relativeLeft = targetRect.left - inputRect.left;
      const relativeTop = targetRect.top - inputRect.top;
      const targetWidth = targetRect.width;
      
      // Position tooltip below the word, centered
      const tooltipLeft = relativeLeft + (targetWidth / 2);
      const tooltipTop = relativeTop + 25;
      
      customTooltip.style.left = tooltipLeft + 'px';
      customTooltip.style.top = tooltipTop + 'px';
      customTooltip.style.transform = 'translateX(-50%)'; // Center horizontally
    }

    // Update tooltip immediately when variant changes
    function updateCurrentTooltip() {
      if (currentTooltipWord) {
        updateTooltipContent(currentTooltipWord);
      }
    }

    // Get absolute text position ignoring HTML markup
    function getAbsoluteTextOffset(container, node, offset) {
      const walker = document.createTreeWalker(
        container,
        NodeFilter.SHOW_TEXT,
        null,
        false
      );

      let textOffset = 0;
      let currentNode;
      
      while (currentNode = walker.nextNode()) {
        if (currentNode === node) {
          return textOffset + offset;
        }
        textOffset += currentNode.textContent.length;
      }
      
      return textOffset;
    }

    // Restore cursor to specific text position
    function restoreCursorToTextOffset(container, targetOffset) {
      // Only restore cursor if the container is already focused
      if (document.activeElement !== container) {
        return; // Don't steal focus from other elements
      }
      const walker = document.createTreeWalker(
        container,
        NodeFilter.SHOW_TEXT,
        null,
        false
      );

      let currentOffset = 0;
      let node;
      
      while (node = walker.nextNode()) {
        const nodeLength = node.textContent.length;
        if (currentOffset + nodeLength >= targetOffset) {
          const selection = window.getSelection();
          const range = document.createRange();
          const offsetInNode = Math.min(targetOffset - currentOffset, nodeLength);
          
          range.setStart(node, offsetInNode);
          range.setEnd(node, offsetInNode);
          selection.removeAllRanges();
          selection.addRange(range);
          return;
        }
        currentOffset += nodeLength;
      }
      
      // If we couldn't find the position, place cursor at end
      const selection = window.getSelection();
      const range = document.createRange();
      range.selectNodeContents(container);
      range.collapse(false);
      selection.removeAllRanges();
      selection.addRange(range);
    }

    // Clean up any broken HTML markup that can cause style inheritance issues
    function cleanupBrokenMarkup() {
      const currentText = getPlainTextFromInput();
      
      // Check for various types of broken markup
      const hasSpans = englishInput.innerHTML.includes('<span');
      const hasProperVariantSpans = englishInput.querySelectorAll('.variant-word').length > 0;
      const hasOrphanedSpans = englishInput.querySelectorAll('span:not(.variant-word)').length > 0;
      
      // Check if text content differs significantly from innerHTML (indicating broken markup)
      const htmlText = englishInput.innerHTML.replace(/<[^>]*>/g, '');
      const textMismatch = htmlText !== currentText;
      
      // If we have problems, clean up
      if ((hasSpans && !hasProperVariantSpans) || hasOrphanedSpans || textMismatch) {
        console.log('Detected broken markup, cleaning up...', {
          hasSpans,
          hasProperVariantSpans, 
          hasOrphanedSpans,
          textMismatch
        });
        
        // Save cursor position
        const selection = window.getSelection();
        let cursorTextOffset = 0;
        
        if (selection.rangeCount > 0) {
          const range = selection.getRangeAt(0);
          cursorTextOffset = getAbsoluteTextOffset(englishInput, range.startContainer, range.startOffset);
        }
        
        // Reset to plain text cleanly
        englishInput.innerHTML = '';
        if (currentText) {
          englishInput.appendChild(document.createTextNode(currentText));
        }
        
        // Restore cursor
        restoreCursorToTextOffset(englishInput, cursorTextOffset);
        
        return true; // Indicate we cleaned up
      }
      
      return false; // No cleanup needed
    }

    // Get plain text content from the contenteditable div
    function getPlainTextFromInput() {
      return englishInput.textContent || englishInput.innerText || "";
    }

    // Copy to clipboard functionality
    ichrolicOutput.addEventListener('click', function() {
      const text = ichrolicOutput.value;
      if (text.trim() === '') {
        return; // Don't copy if there's no text
      }

      // Use the modern clipboard API if available
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).then(function() {
          showCopyFeedback();
        }).catch(function() {
          // Fallback to the older method
          fallbackCopyTextToClipboard(text);
        });
      } else {
        // Fallback for older browsers
        fallbackCopyTextToClipboard(text);
      }
    });

    // Fallback copy method for older browsers
    function fallbackCopyTextToClipboard(text) {
      const textArea = document.createElement("textarea");
      textArea.value = text;
      
      // Avoid scrolling to bottom
      textArea.style.top = "0";
      textArea.style.left = "0";
      textArea.style.position = "fixed";

      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();

      try {
        const successful = document.execCommand('copy');
        if (successful) {
          showCopyFeedback();
        }
      } catch (err) {
        console.error('Fallback: Oops, unable to copy', err);
      }

      document.body.removeChild(textArea);
    }

    // Show copy feedback animation
    function showCopyFeedback() {
      copyFeedback.classList.add('show');
      setTimeout(() => {
        copyFeedback.classList.remove('show');
      }, 1500);
    }

    // Developer mode functionality
    function enterDeveloperMode() {
      console.log('=== Entering Developer Mode ===');
      isDeveloperMode = true;
      
      // Add dev mode class to title and dev menu toggle
      pageTitle.classList.add('dev-mode');
      devMenuToggle.classList.add('dev-mode');
      
      // Add dev mode class to container to show dev-only settings
      document.querySelector('.container').classList.add('dev-mode');
      
      // Change title based on screen size
      updateDeveloperTitle();
      
      // Show developer menu
      devMenu.classList.add('show');
      console.log('Dev menu shown, button should be visible');
      
      // Change save button text and style
      saveDictionaryButton.textContent = 'Update Dictionary';
      saveDictionaryButton.classList.add('goldenrod-button');
      console.log('Save button updated to:', saveDictionaryButton.textContent);
      
      // Clear the input field only if triggered by typing "/////", not auto-login
      if (getPlainTextFromInput() === '/////') {
        englishInput.innerHTML = '';
        ichrolicOutput.value = '';
        console.log('Cleared input fields (triggered by typing)');
      } else {
        console.log('Auto-login detected, keeping input fields as-is');
      }
    }

    function exitDeveloperMode() {
      isDeveloperMode = false;
      
      // Remove dev mode classes
      pageTitle.classList.remove('dev-mode');
      devMenuToggle.classList.remove('dev-mode');
      document.querySelector('.container').classList.remove('dev-mode');
      
      // Revert title
      pageTitle.textContent = 'Ichrolic Translator';
      
      // Hide developer menu
      devMenu.classList.remove('show');
      devMenuDropdown.classList.remove('show');
      
      // Revert save button text and style
      saveDictionaryButton.textContent = 'Save Dictionary';
      saveDictionaryButton.classList.remove('goldenrod-button');
    }

    function updateDeveloperTitle() {
      if (isDeveloperMode) {
        // Check if we're in mobile view (where emoji toggle is visible)
        if (window.innerWidth <= 422) {
          pageTitle.textContent = ';)';
        } else {
          pageTitle.textContent = 'Ichrolic Editor';
        }
      }
    }

    // Update title on window resize if in developer mode
    window.addEventListener('resize', function() {
      updateDeveloperTitle();
      updateDictionaryTable();
    });

    // Developer menu toggle
    devMenuToggle.addEventListener('click', function(e) {
      e.stopPropagation();
      devMenuDropdown.classList.toggle('show');
    });

    // Close dropdown when clicking outside
    document.addEventListener('click', function() {
      devMenuDropdown.classList.remove('show');
    });

    // Developer menu item event handlers
    devSignIn.addEventListener('click', function() {
      if (githubToken && currentUser) {
        // Already signed in, offer to sign out
        if (confirm(`Sign out from ${currentUser.login}?`)) {
          handleSignOut();
        }
      } else {
        // Not signed in, show sign in modal
        showSignInModal();
      }
      devMenuDropdown.classList.remove('show');
    });

    devClose.addEventListener('click', function() {
      exitDeveloperMode();
      devMenuDropdown.classList.remove('show');
    });

    // Sign-in modal event listeners
    confirmSignIn.addEventListener('click', handleSignIn);
    cancelSignIn.addEventListener('click', hideSignInModal);

    // Close modal when clicking outside
    signInModal.addEventListener('click', function(e) {
      if (e.target === signInModal) {
        hideSignInModal();
      }
    });

    // Handle Enter key in token input
    tokenInput.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        handleSignIn();
      }
    });

    // Check for developer mode trigger and handle input changes
    englishInput.addEventListener('input', function(e) {
      const text = getPlainTextFromInput();
      if (text === '/////') {
        enterDeveloperMode();
        return;
      }
      
      // Always translate on input changes
      clearTimeout(englishInput.translateTimeout);
      englishInput.translateTimeout = setTimeout(() => {
        translateToIchrolic();
      }, 50);
      
      // Only rebuild display in specific cases to avoid cursor issues
      if (e.inputType === 'insertText' && e.data === ' ') {
        // User typed a space - finished a word, mark variants
        clearTimeout(englishInput.displayTimeout);
        englishInput.displayTimeout = setTimeout(() => {
          updateEnglishInputDisplay();
        }, 200);
      } else if (e.inputType === 'deleteContentBackward' || e.inputType === 'deleteContentForward') {
        // User deleted content - may have removed variant markup or left dangling HTML
        clearTimeout(englishInput.displayTimeout);
        englishInput.displayTimeout = setTimeout(() => {
          // Clean up any potential HTML mess first
          cleanupBrokenMarkup();
          updateEnglishInputDisplay();
        }, 100);
      } else if (e.inputType === 'insertParagraph' || e.inputType === 'insertLineBreak') {
        // User pressed Enter
        clearTimeout(englishInput.displayTimeout);
        englishInput.displayTimeout = setTimeout(() => {
          updateEnglishInputDisplay();
        }, 100);
      }
    });

    // Update display when user focuses the field (if it needs updating)
    englishInput.addEventListener('focus', function() {
      const text = getPlainTextFromInput().trim();
      if (!text) return;
      
      const hasVariants = text.split(/\s+/).some(word => {
        const cleanWord = word.toLowerCase().replace(/[.,!?;:]/g, '');
        return wordVariants[cleanWord];
      });
      
      if (hasVariants && englishInput.innerHTML === englishInput.textContent) {
        // Only rebuild if we have variants but no HTML markup yet
        updateEnglishInputDisplay();
      }
    });

    // Update display when user leaves the field (catches words typed without spaces)
    englishInput.addEventListener('blur', function() {
      // Small delay to ensure focus has actually left
      setTimeout(() => {
        if (document.activeElement !== englishInput) {
          const text = getPlainTextFromInput().trim();
          if (text) {
            const hasVariants = text.split(/\s+/).some(word => {
              const cleanWord = word.toLowerCase().replace(/[.,!?;:]/g, '');
              return wordVariants[cleanWord];
            });
            
            if (hasVariants) {
              updateEnglishInputDisplay();
            }
          }
        }
      }, 10);
    });

    // Handle paste events to maintain plain text
    englishInput.addEventListener('paste', function(e) {
      e.preventDefault();
      const text = (e.originalEvent || e).clipboardData.getData('text/plain');
      document.execCommand('insertText', false, text);
    });

    // Prevent rich formatting and catch typing after partial deletions
    englishInput.addEventListener('keydown', function(e) {
      // Prevent formatting shortcuts
      if (e.ctrlKey || e.metaKey) {
        if (['b', 'i', 'u'].includes(e.key.toLowerCase())) {
          e.preventDefault();
        }
      }
      
      // If user is typing a letter and we detect potential style inheritance,
      // clean it up immediately
      if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
        // Quick check: if cursor is in a position that might inherit styles
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
          const range = selection.getRangeAt(0);
          const container = range.startContainer;
          
          // If we're typing in a span that's not a proper variant word, clean up
          if (container.parentElement && 
            container.parentElement.tagName === 'SPAN' && 
            !container.parentElement.classList.contains('variant-word')) {
            
            // Schedule cleanup after the character is inserted
            setTimeout(() => {
              cleanupBrokenMarkup();
            }, 0);
          }
        }
      }
    });
    function isMobileView() {
      return window.innerWidth <= 768;
    }



    // Event Listeners (translation is handled in the input event above)
    ignoreDiacriticsCheckbox.addEventListener('change', translateToIchrolic);
    useContractionsCheckbox.addEventListener('change', translateToIchrolic);
    saveDictionaryButton.addEventListener('click', saveDictionary);
    showDictionaryButton.addEventListener('click', toggleDictionaryTable);
    addEntryButton.addEventListener('click', addDictionaryEntry);
    dictionarySearchInput.addEventListener('input', updateDictionaryTable);
    showSynonymsCheckbox.addEventListener('change', updateDictionaryTable);
    englishHeader.addEventListener('click', () => sortDictionary('english'));
    ichrolicHeader.addEventListener('click', () => sortDictionary('ichrolic'));
    synonymToggleButton.addEventListener('click', toggleSynonymMode);

    // GitHub API functions
    async function testGitHubToken(token) {
      try {
        const response = await fetch('https://api.github.com/user', {
          headers: {
            'Authorization': `token ${token}`,
            'Accept': 'application/vnd.github.v3+json'
          }
        });
        
        if (response.ok) {
          return await response.json();
        } else {
          throw new Error(`GitHub API error: ${response.status}`);
        }
      } catch (error) {
        throw new Error(`Failed to verify token: ${error.message}`);
      }
    }

    async function fetchCurrentDictionary() {
      try {
        const response = await fetch('https://api.github.com/repos/AltoneInteractive/AltoneInteractive.github.io/contents/dictionary.json', {
          headers: {
            'Authorization': `token ${githubToken}`,
            'Accept': 'application/vnd.github.v3+json'
          }
        });
        
        if (response.ok) {
          return await response.json();
        } else {
          throw new Error(`Failed to fetch dictionary: ${response.status}`);
        }
      } catch (error) {
        throw new Error(`GitHub API error: ${error.message}`);
      }
    }

    async function updateDictionaryOnGitHub(newContent, currentSha) {
      try {
        // Create the JSON string
        const jsonString = JSON.stringify(newContent, null, 2);
        
        // Properly encode UTF-8 to base64
        // First encode as UTF-8 bytes, then convert to base64
        const utf8Bytes = new TextEncoder().encode(jsonString);
        let binaryString = '';
        for (let i = 0; i < utf8Bytes.length; i++) {
          binaryString += String.fromCharCode(utf8Bytes[i]);
        }
        const base64Content = btoa(binaryString);
        
        const response = await fetch('https://api.github.com/repos/AltoneInteractive/AltoneInteractive.github.io/contents/dictionary.json', {
          method: 'PUT',
          headers: {
            'Authorization': `token ${githubToken}`,
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            message: `Update dictionary via Ichrolic Editor - ${new Date().toISOString()}`,
            content: base64Content,
            sha: currentSha
          })
        });
        
        if (response.ok) {
          return await response.json();
        } else {
          throw new Error(`Failed to update dictionary: ${response.status}`);
        }
      } catch (error) {
        throw new Error(`Update failed: ${error.message}`);
      }
    }

    // Sign-in functionality
    function showSignInModal() {
      signInModal.classList.add('show');
      tokenInput.value = '';
      tokenInput.focus();
    }

    function hideSignInModal() {
      signInModal.classList.remove('show');
    }

    function updateSignInState() {
      if (githubToken && currentUser) {
        signInText.innerHTML = `${currentUser.login} <span class="signed-in-indicator">✓</span>`;
      } else {
        signInText.textContent = 'Sign In';
      }
    }

    async function handleSignIn() {
      const token = tokenInput.value.trim();
      if (!token) {
        alert('Please enter a GitHub token');
        return;
      }

      // Show loading state
      confirmSignIn.classList.add('loading');
      confirmSignIn.disabled = true;

      try {
        const user = await testGitHubToken(token);
        
        // Store token and user info
        githubToken = token;
        currentUser = user;
        localStorage.setItem('github_token', token);
        localStorage.setItem('github_user', JSON.stringify(user));
        
        updateSignInState();
        hideSignInModal();
        
        dictionaryStatus.textContent = `Signed in as ${user.login}`;
        setTimeout(() => {
          dictionaryStatus.textContent = "";
        }, 3000);
        
      } catch (error) {
        alert(`Sign in failed: ${error.message}`);
      } finally {
        confirmSignIn.classList.remove('loading');
        confirmSignIn.disabled = false;
      }
    }

    function handleSignOut() {
      githubToken = null;
      currentUser = null;
      localStorage.removeItem('github_token');
      localStorage.removeItem('github_user');
      updateSignInState();
      
      // Exit developer mode when signing out
      if (isDeveloperMode) {
        exitDeveloperMode();
      }
      
      dictionaryStatus.textContent = "Signed out";
      setTimeout(() => {
        dictionaryStatus.textContent = "";
      }, 3000);
    }
    function removeDiacriticsForSearch(text) {
      if (!text) return text;

      // Map of characters with diacritics to their base form
      const diacriticMap = {
        "í": "i", "é": "e", "á": "a", "ó": "o", "ú": "u",
        "ì": "i", "è": "e", "à": "a", "ò": "o", "ù": "u",
        "î": "i", "ê": "e", "â": "a", "ô": "o", "û": "u",
        "ï": "i", "ë": "e", "ä": "a", "ö": "o", "ü": "u"
      };

      let result = text.toLowerCase();
      for (const diacritic in diacriticMap) {
        result = result.split(diacritic).join(diacriticMap[diacritic]);
      }

      return result;
    }

    // Function to update the dictionary table
    function updateDictionaryTable() {
      const showSynonyms = showSynonymsCheckbox.checked;
      const searchTerm = dictionarySearchInput.value.toLowerCase();

      // Clear both table views
      dictionaryBody.innerHTML = '';
      mobileTable.innerHTML = '';

      // Get a list of all entries to display
      const entries = [];

      // Add main dictionary entries
      for (const english in dictionary) {
        const normalizedEnglish = removeDiacriticsForSearch(english);
        const normalizedIchrolic = removeDiacriticsForSearch(dictionary[english]);
        const normalizedSearch = removeDiacriticsForSearch(searchTerm);
        
        if (searchTerm === '' ||
          normalizedEnglish.includes(normalizedSearch) ||
          normalizedIchrolic.includes(normalizedSearch)) {
          entries.push({
            english: english,
            ichrolic: dictionary[english],
            isSynonym: false
          });
        }
      }

      // Add synonym entries if enabled
      if (showSynonyms) {
        for (const synonym in synonyms) {
          const canonicalForm = synonyms[synonym];
          if (dictionary.hasOwnProperty(canonicalForm)) {
            const normalizedSynonym = removeDiacriticsForSearch(synonym);
            const normalizedIchrolic = removeDiacriticsForSearch(dictionary[canonicalForm]);
            const normalizedSearch = removeDiacriticsForSearch(searchTerm);
            
            if (searchTerm === '' ||
              normalizedSynonym.includes(normalizedSearch) ||
              normalizedIchrolic.includes(normalizedSearch)) {
              entries.push({
                english: synonym,
                ichrolic: dictionary[canonicalForm],
                isSynonym: true,
                canonicalForm: canonicalForm
              });
            }
          }
        }
      }

      // Sort entries with smart search relevance
      if (searchTerm !== '') {
        // Smart search sorting: exact match -> starts with -> contains
        entries.sort((a, b) => {
          const aEnglish = removeDiacriticsForSearch(a.english);
          const bEnglish = removeDiacriticsForSearch(b.english);
          const aIchrolic = removeDiacriticsForSearch(a.ichrolic);
          const bIchrolic = removeDiacriticsForSearch(b.ichrolic);
          const normalizedSearch = removeDiacriticsForSearch(searchTerm);
          
          // Calculate relevance scores
          const getRelevanceScore = (english, ichrolic) => {
            // Exact match gets highest score
            if (english === normalizedSearch || ichrolic === normalizedSearch) return 100;
            
            // Starts with search term gets high score
            if (english.startsWith(normalizedSearch) || ichrolic.startsWith(normalizedSearch)) return 50;
            
            // Contains search term gets lower score
            if (english.includes(normalizedSearch) || ichrolic.includes(normalizedSearch)) return 10;
            
            return 0;
          };
          
          const scoreA = getRelevanceScore(aEnglish, aIchrolic);
          const scoreB = getRelevanceScore(bEnglish, bIchrolic);
          
          // If scores are different, sort by relevance (higher score first)
          if (scoreA !== scoreB) {
            return scoreB - scoreA;
          }
          
          // If same relevance score, fall back to alphabetical sorting
          const fieldA = currentSortField === 'english' ? aEnglish : aIchrolic;
          const fieldB = currentSortField === 'english' ? bEnglish : bIchrolic;
          
          if (sortDirection === 'asc') {
            return fieldA.localeCompare(fieldB);
          } else {
            return fieldB.localeCompare(fieldA);
          }
        });
      } else {
        // No search term, use regular sorting
        entries.sort((a, b) => {
          const fieldA = currentSortField === 'english' ? a.english.toLowerCase() : a.ichrolic.toLowerCase();
          const fieldB = currentSortField === 'english' ? b.english.toLowerCase() : b.ichrolic.toLowerCase();

          if (sortDirection === 'asc') {
            return fieldA.localeCompare(fieldB);
          } else {
            return fieldB.localeCompare(fieldA);
          }
        });
      }

      // Display entries
      const isMobile = isMobileView();
      
      // Update desktop view
      if (!isMobile) {
        for (const entry of entries) {
          const row = document.createElement('tr');
          if (entry.isSynonym) {
            row.classList.add('synonym-row');
          }

          const englishCell = document.createElement('td');
          englishCell.textContent = entry.english;
          if (entry.isSynonym) {
            englishCell.textContent += ` (→ ${entry.canonicalForm})`;
          }

          const ichrolicCell = document.createElement('td');
          ichrolicCell.textContent = entry.ichrolic;

          const actionsCell = document.createElement('td');

          // Create delete button
          const deleteButton = document.createElement('button');
          deleteButton.textContent = 'Delete';
          deleteButton.style.backgroundColor = '#ec474f';
          deleteButton.style.marginRight = '5px';
          deleteButton.addEventListener('click', function() {
            if (entry.isSynonym) {
              delete synonyms[entry.english];
            } else {
              delete dictionary[entry.english];
            }
            buildVariantMapping();
            updateDictionaryTable();
            translateToIchrolic();
          });

          actionsCell.appendChild(deleteButton);

          // Create edit button for primary entries
          if (!entry.isSynonym) {
            const editButton = document.createElement('button');
            editButton.textContent = 'Edit';
            editButton.style.marginLeft = '5px';
            editButton.addEventListener('click', function() {
              // Populate the input fields with the current values - SECURE
              newEnglishInput.value = entry.english; // using .value is safe
              newIchrolicInput.value = entry.ichrolic; // using .value is safe

              // Remove the old entry
              delete dictionary[entry.english];

              // Focus on the ichrolic input for editing
              newIchrolicInput.focus();

              buildVariantMapping();
              updateDictionaryTable();
            });
            actionsCell.appendChild(editButton);
          }

          // Only show "Make primary" button for synonyms
          if (entry.isSynonym) {
            const makePrimaryButton = document.createElement('button');
            makePrimaryButton.textContent = 'Make Primary';
            makePrimaryButton.style.backgroundColor = '#a9bbd0';
            makePrimaryButton.style.marginLeft = '5px';
            makePrimaryButton.addEventListener('click', function() {
              // Get the translation from the canonical form
              const translation = dictionary[entry.canonicalForm];

              // Remove the synonym
              delete synonyms[entry.english];

              // Add as a primary entry
              dictionary[entry.english] = translation;

              buildVariantMapping();
              updateDictionaryTable();
              translateToIchrolic();
            });

            actionsCell.appendChild(makePrimaryButton);
          }

          row.appendChild(englishCell);
          row.appendChild(ichrolicCell);
          row.appendChild(actionsCell);
          dictionaryBody.appendChild(row);
        }
      } else {
        // Mobile view entries
        for (const entry of entries) {
          const entryDiv = document.createElement('div');
          entryDiv.className = 'mobile-table-entry';
          if (entry.isSynonym) {
            entryDiv.classList.add('synonym-row');
          }
          
          // English row
          const englishRow = document.createElement('div');
          englishRow.className = 'mobile-table-row';
          
          const englishLabel = document.createElement('div');
          englishLabel.className = 'mobile-table-label';
          englishLabel.textContent = 'English:';
          
          const englishValue = document.createElement('div');
          englishValue.className = 'mobile-table-value';
          englishValue.textContent = entry.english;
          if (entry.isSynonym) {
            englishValue.textContent += ` (→ ${entry.canonicalForm})`;
          }
          
          englishRow.appendChild(englishLabel);
          englishRow.appendChild(englishValue);
          entryDiv.appendChild(englishRow);
          
          // Ichrolic row
          const ichrolicRow = document.createElement('div');
          ichrolicRow.className = 'mobile-table-row';
          
          const ichrolicLabel = document.createElement('div');
          ichrolicLabel.className = 'mobile-table-label';
          ichrolicLabel.textContent = 'Ichrolic:';
          
          const ichrolicValue = document.createElement('div');
          ichrolicValue.className = 'mobile-table-value';
          ichrolicValue.textContent = entry.ichrolic;
          
          ichrolicRow.appendChild(ichrolicLabel);
          ichrolicRow.appendChild(ichrolicValue);
          entryDiv.appendChild(ichrolicRow);
          
          // Actions row
          const actionsDiv = document.createElement('div');
          actionsDiv.className = 'mobile-table-actions';
          
          // Create delete button
          const deleteButton = document.createElement('button');
          deleteButton.textContent = 'Delete';
          deleteButton.style.backgroundColor = '#ec474f';
          deleteButton.addEventListener('click', function() {
            if (entry.isSynonym) {
              delete synonyms[entry.english];
            } else {
              delete dictionary[entry.english];
            }
            buildVariantMapping();
            updateDictionaryTable();
            translateToIchrolic();
          });
          
          actionsDiv.appendChild(deleteButton);
          
          // Create edit button for primary entries
          if (!entry.isSynonym) {
            const editButton = document.createElement('button');
            editButton.textContent = 'Edit';
            editButton.addEventListener('click', function() {
              // Populate the input fields with the current values
              newEnglishInput.value = entry.english;
              newIchrolicInput.value = entry.ichrolic;

              // Remove the old entry
              delete dictionary[entry.english];

              // Focus on the ichrolic input for editing
              newIchrolicInput.focus();

              buildVariantMapping();
              updateDictionaryTable();
            });
            actionsDiv.appendChild(editButton);
          }
          
          // Only show "Make primary" button for synonyms
          if (entry.isSynonym) {
            const makePrimaryButton = document.createElement('button');
            makePrimaryButton.textContent = 'Make Primary';
            makePrimaryButton.style.backgroundColor = '#a9bbd0';
            makePrimaryButton.addEventListener('click', function() {
              // Get the translation from the canonical form
              const translation = dictionary[entry.canonicalForm];

              // Remove the synonym
              delete synonyms[entry.english];

              // Add as a primary entry
              dictionary[entry.english] = translation;

              buildVariantMapping();
              updateDictionaryTable();
              translateToIchrolic();
            });

            actionsDiv.appendChild(makePrimaryButton);
          }
          
          entryDiv.appendChild(actionsDiv);
          mobileTable.appendChild(entryDiv);
        }
      }

      // Show/hide appropriate view based on screen size
      if (isMobile) {
        document.getElementById('desktopTable').style.display = 'none';
        document.getElementById('mobileTable').style.display = 'block';
      } else {
        document.getElementById('desktopTable').style.display = 'table';
        document.getElementById('mobileTable').style.display = 'none';
      }

      // Update empty dictionary message visibility
      const emptyDictionary = document.getElementById('emptyDictionary');
      if (entries.length === 0) {
        emptyDictionary.style.display = 'block';
      } else {
        emptyDictionary.style.display = 'none';
      }
    }

    // Function to toggle between direct entry and synonym modes:
    function toggleSynonymMode() {
      isSynonymMode = !isSynonymMode;

      if (isSynonymMode) {
        synonymToggleButton.textContent = "→";
        newIchrolicInput.placeholder = "Synonym for";
        synonymToggleButton.title = "Currently in synonym mode";
      } else {
        synonymToggleButton.textContent = "=";
        newIchrolicInput.placeholder = "Ichrolic translation";
        synonymToggleButton.title = "Currently in direct translation mode";
      }
    }

    // Add dictionary entry function
    function addDictionaryEntry() {
      const english = newEnglishInput.value.trim();
      const ichrolic = newIchrolicInput.value.trim();

      if (english === '') {
        dictionaryStatus.textContent = "English field must be filled.";
        return;
      }

      if (ichrolic === '' && !isSynonymMode) {
        dictionaryStatus.textContent = "Ichrolic translation field must be filled.";
        return;
      }

      if (isSynonymMode) {
        // In synonym mode, add as a synonym for the existing entry
        if (!dictionary.hasOwnProperty(ichrolic)) {
          dictionaryStatus.textContent = `Error: "${ichrolic}" is not in the dictionary as a primary entry.`;
          return;
        }

        // Add as a synonym
        synonyms[english.toLowerCase()] = ichrolic.toLowerCase();
        dictionaryStatus.textContent = `Added "${english}" as a synonym for "${ichrolic}".`;
      } else {
        // In direct translation mode, add as a primary entry
        dictionary[english.toLowerCase()] = ichrolic;
        dictionaryStatus.textContent = `Added "${english}" to the dictionary.`;
      }

      // Clear the input fields
      newEnglishInput.value = '';
      newIchrolicInput.value = '';

      // Update the table and translation
      buildVariantMapping();
      updateDictionaryTable();
      translateToIchrolic();

      // Clear status message after 3 seconds
      setTimeout(() => {
        dictionaryStatus.textContent = "";
      }, 3000);
    }

    // Automatically load the dictionary when the page loads
    window.addEventListener('DOMContentLoaded', function() {
      loadDefaultDictionary();
  
      // Check for existing GitHub token and auto-login
      const storedToken = localStorage.getItem('github_token');
      const storedUser = localStorage.getItem('github_user');
      
      if (storedToken && storedUser) {
        try {
          githubToken = storedToken;
          currentUser = JSON.parse(storedUser);
          updateSignInState();
          enterDeveloperMode(); // Auto-enter dev mode if we have credentials
          console.log('Auto-logged in as:', currentUser.login);
        } catch (error) {
          console.error('Failed to parse stored user data:', error);
          // Clear corrupted data
          localStorage.removeItem('github_token');
          localStorage.removeItem('github_user');
        }
      }
    });
    // Function to load the default dictionary from a file in the repo
    function loadDefaultDictionary() {
      // Add cache-busting parameter to always get fresh data
      const cacheBuster = '?t=' + new Date().getTime();
      
      fetch('dictionary.json' + cacheBuster)
        .then(response => {
          if (!response.ok) {
            throw new Error('Failed to load dictionary file. Status: ' + response.status);
          }
          return response.json();
        })
        .then(data => {
          if (data.dictionary && data.synonyms) {
            dictionary = data.dictionary;
            synonyms = data.synonyms;
            buildVariantMapping();
            
            // Only update display if there's content to process
            const text = getPlainTextFromInput();
            if (text.trim()) {
              updateEnglishInputDisplay();
            }
            
            updateDictionaryTable();
            translateToIchrolic();
            dictionaryStatus.textContent = "Default dictionary loaded successfully.";
            
            // Clear status message after 3 seconds
            setTimeout(() => {
              dictionaryStatus.textContent = "";
            }, 3000);
          } else {
            throw new Error('Invalid dictionary format in file.');
          }
        })
        .catch(error => {
          console.error('Error loading dictionary:', error);
          dictionaryStatus.textContent = "Error loading dictionary: " + error.message + ". Using empty dictionary.";
          
          // Initialize with empty dictionary if loading fails
          dictionary = {};
          synonyms = {};
          updateDictionaryTable();
        });
    }

    // Function to translate English to Ichrolic
    function translateToIchrolic() {
      const english = getPlainTextFromInput().trim();
      if (english === "") {
        ichrolicOutput.value = "";
        return;
      }

      const ignoreDiacritics = ignoreDiacriticsCheckbox.checked;
      const useContractions = useContractionsCheckbox.checked;

      // Keep track of capitalization for each word
      const englishWords = english.split(" ");
      const capitalizationMap = {};

      for (let i = 0; i < englishWords.length; i++) {
        const word = englishWords[i];
        if (word.length > 0) {
          capitalizationMap[i] = word[0] === word[0].toUpperCase();
        }
      }

      // Build dictionary for translation including variants
      const translationDictionary = { ...dictionary };
      
      // Add selected variants to translation dictionary
      for (const baseWord in wordVariants) {
        const variant = getSelectedVariant(baseWord);
        if (variant) {
          translationDictionary[baseWord] = variant.translation;
        }
      }

      // Sort dictionary keys by length (descending) to prioritize longer phrases
      const sortedKeys = Object.keys(translationDictionary).sort((a, b) =>
        b.split(" ").length - a.split(" ").length
      );

      // Tokenize the English text, preserving punctuation
      const tokens = [];
      let currentWord = "";
      const punctuationChars = [",", ".", "!", "?", ";", ":"];

      for (const c of english) {
        if (c === " ") {
          if (currentWord !== "") {
            tokens.push(currentWord);
            currentWord = "";
          }
          tokens.push(" ");
        } else if (punctuationChars.includes(c)) {
          if (currentWord !== "") {
            tokens.push(currentWord);
            currentWord = "";
          }
          tokens.push(c);
        } else {
          currentWord += c;
        }
      }

      if (currentWord !== "") {
        tokens.push(currentWord);
      }

      // Find multi-word phrases and translate
      let i = 0;
      const result = [];
      const resultToEnglishIndex = {};
      let englishIndex = 0;

      while (i < tokens.length) {
        let foundPhrase = false;

        // Skip spaces
        if (tokens[i] === " ") {
          result.push(" ");
          i++;
          continue;
        }

        // Check if punctuation
        if (tokens[i].length === 1 && punctuationChars.includes(tokens[i])) {
          result.push(tokens[i]);
          i++;
          continue;
        }

        // Try to match multi-word phrases
        for (const key of sortedKeys) {
          if (key.includes(" ")) {  // Multi-word phrase
            const phraseWords = key.split(" ");
            let potentialMatch = true;
            const phraseTokens = [];
            let j = i;

            // Collect tokens that might form the phrase
            for (const word of phraseWords) {
              if (j >= tokens.length || tokens[j] === " " || punctuationChars.includes(tokens[j])) {
                j++;
                continue;
              }

              phraseTokens.push(tokens[j].toLowerCase());
              j++;

              // Skip spaces
              if (j < tokens.length && tokens[j] === " ") {
                j++;
              }
            }

            // Check if we have a match
            if (phraseTokens.length === phraseWords.length) {
              const matchStr = phraseTokens.join(" ");
              if (matchStr.toLowerCase() === key.toLowerCase()) {
                foundPhrase = true;
                result.push(translationDictionary[key]);

                // Map this result to the English word
                resultToEnglishIndex[result.length - 1] = englishIndex;

                // Skip the matched tokens
                for (let k = 0; k < phraseWords.length * 2 - 1; k++) {
                  if (i < tokens.length) {
                    if (tokens[i] !== " " && !punctuationChars.includes(tokens[i])) {
                      englishIndex++;
                    }
                    i++;
                  }
                }

                break;
              }
            }
          }
        }

        // If no phrase match, process as regular word
        if (!foundPhrase && i < tokens.length) {
          const token = tokens[i];

          // Skip spaces
          if (token === " ") {
            result.push(" ");
            i++;
            continue;
          }

          // Process punctuation
          if (token.length === 1 && punctuationChars.includes(token)) {
            result.push(token);
            i++;
            continue;
          }

          // Process regular word
          const cleanWord = token.toLowerCase();
          const canonicalWord = getCanonicalForm(cleanWord);

          if (translationDictionary.hasOwnProperty(canonicalWord)) {
            result.push(translationDictionary[canonicalWord]);
            resultToEnglishIndex[result.length - 1] = englishIndex;
          } else {
            result.push("[" + token + "]");
            resultToEnglishIndex[result.length - 1] = englishIndex;
          }

          englishIndex++;
          i++;
        }
      }

      // Join the result, properly handling spaces and punctuation
      let finalResult = "";
      for (let j = 0; j < result.length; j++) {
        const token = result[j];

        if (token === " ") {
          finalResult += " ";
        } else if (token.length === 1 && punctuationChars.includes(token)) {
          // Don't add space before punctuation
          finalResult += token;
        } else {
          // Add space before words if needed
          if (j > 0 && result[j-1] !== " " && !(result[j-1].length === 1 && punctuationChars.includes(result[j-1]))) {
            finalResult += " ";
          }
          finalResult += token;
        }
      }

      let ichrolic = finalResult.trim();

      // Apply synonym handling for phrases
      for (const synonymKey in synonyms) {
        if (synonymKey.includes(" ")) {
          const canonicalKey = synonyms[synonymKey];
          if (dictionary.hasOwnProperty(canonicalKey)) {
            const pattern = "\\[" + synonymKey.replace(/ /g, "\\] \\[") + "\\]";
            const regex = new RegExp(pattern, "g");
            const matches = ichrolic.match(regex);
            if (matches && matches.length > 0) {
              for (const match of matches) {
                ichrolic = ichrolic.replace(match, dictionary[canonicalKey]);
              }
            }
          }
        }
      }

      // Apply contractions if the option is enabled
      if (useContractions) {
        ichrolic = applyContractions(ichrolic, capitalizationMap, resultToEnglishIndex);
      }

      // Remove diacritics if the option is enabled
      if (ignoreDiacritics) {
        ichrolic = removeDiacritics(ichrolic);
      }

      ichrolicOutput.value = ichrolic;
    }

    // Function to get canonical form from synonyms and variants
    function getCanonicalForm(word) {
      const lowercaseWord = word.toLowerCase();

      // First check if there's a selected variant for this word
      if (wordVariants[lowercaseWord]) {
        const variant = getSelectedVariant(lowercaseWord);
        return variant ? variant.key : lowercaseWord;
      }

      // Check if word already exists in main dictionary
      if (dictionary.hasOwnProperty(lowercaseWord)) {
        return lowercaseWord;
      }

      // Check if word is a synonym
      if (synonyms.hasOwnProperty(lowercaseWord)) {
        return synonyms[lowercaseWord];
      }

      return lowercaseWord;  // Return original if not found
    }

    // Function to apply contractions
    function applyContractions(text, capitalizationMap, resultToEnglishIndex) {
      if (!useContractionsCheckbox.checked) {
        return text;
      }

      // Split text by terminal punctuation
      const terminalPunctuation = [".", "!", "?", ","];
      const segments = [];
      let currentSegment = "";

      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        currentSegment += char;

        if (terminalPunctuation.includes(char)) {
          segments.push(currentSegment);
          currentSegment = "";
        }
      }

      // Add any remaining text
      if (currentSegment !== "") {
        segments.push(currentSegment);
      }

      // Process each segment separately
      const processedSegments = segments.map(segment =>
        processSegmentContractions(segment, capitalizationMap, resultToEnglishIndex)
      );

      // Join the segments
      return processedSegments.join(" ").trim();
    }

    // Process contractions within a single segment
    function processSegmentContractions(segment, capitalizationMap, resultToEnglishIndex) {
      // List of mergable words
      const mergableWords = [
        "ali",
        "ìkè"
      ];
  
      // Prefixes that should always combine with the following word
      const prefixes = [
        "èden",
        "al-",
        "yana",
        "ky"
      ];
  
      // Suffixes that should always combine with the preceding word
      const suffixes = [
        "íka"
        //"yuhni"
      ];
  
      // Helper function to check if a word is "special" (mergeable, prefix, or suffix)
      const isSpecialWord = (word) => {
        const lowerWord = word.toLowerCase();
        return mergableWords.includes(lowerWord) || 
             prefixes.includes(lowerWord) || 
             suffixes.includes(lowerWord);
      };
  
      const words = segment.trim().split(" ");
      const result = [];
      let i = 0;
      const skipIndices = new Set();
      const mergedPositions = new Set(); // Track which result positions contain merged words
  
      while (i < words.length) {
        // Skip if this index has been marked for skipping
        if (skipIndices.has(i)) {
          i++;
          continue;
        }
  
        const currentWord = words[i];
        let combined = false;
  
        // Check for prefixes
        if (i < words.length - 1 && prefixes.includes(currentWord.toLowerCase())) {
          const nextWord = words[i+1];
  
          // Check if the corresponding English word is capitalized
          let isCapitalized = false;
          if (resultToEnglishIndex.hasOwnProperty(i)) {
            isCapitalized = capitalizationMap[resultToEnglishIndex[i]] || false;
          }
  
          result.push(mergeWords(currentWord, nextWord, isCapitalized, false));
          mergedPositions.add(result.length - 1); // Mark this position as merged
          skipIndices.add(i + 1);
          i++;
          combined = true;
        }
  
        // Check for suffixes on the previous word - but look ahead for special words
        if (!combined && suffixes.includes(currentWord.toLowerCase()) && i > 0 && result.length > 0) {
          // Look ahead to see if the next word is special and would want to merge with current word
          let shouldDeferToNext = false;
          if (i < words.length - 1) {
            const nextWord = words[i + 1];
            if (isSpecialWord(nextWord)) {
              shouldDeferToNext = true;
            }
          }
  
          // Don't merge if the previous result position is already a merged word or if we should defer
          if (!mergedPositions.has(result.length - 1) && !shouldDeferToNext) {
            const prevWord = result[result.length - 1];
  
            // Check if the corresponding English word is capitalized
            let isCapitalized = false;
            if (resultToEnglishIndex.hasOwnProperty(i - 1)) {
              isCapitalized = capitalizationMap[resultToEnglishIndex[i - 1]] || false;
            }
  
            result.pop();
            result.push(mergeWords(prevWord, currentWord, isCapitalized, false));
            mergedPositions.add(result.length - 1); // Mark this position as merged
            combined = true;
          }
        }
  
        // Check if current word is a mergable word
        if (!combined && mergableWords.includes(currentWord.toLowerCase())) {
          // Check if we can combine with previous word
          if (i > 0 && result.length > 0 && !mergedPositions.has(result.length - 1)) {
            const prevWord = result[result.length - 1];
  
            // Check if the corresponding English word is capitalized
            let isCapitalized = false;
            if (resultToEnglishIndex.hasOwnProperty(i - 1)) {
              isCapitalized = capitalizationMap[resultToEnglishIndex[i - 1]] || false;
            }
  
            // Remove the last added word and combine
            result.pop();
            result.push(mergeWords(prevWord, currentWord, isCapitalized));
            mergedPositions.add(result.length - 1); // Mark this position as merged
            combined = true;
          }
  
          // Check if we can combine with next word (if not already combined)
          if (!combined && i < words.length - 1) {
            const nextWord = words[i+1];
  
            // Check if the corresponding English word is capitalized
            let isCapitalized = false;
            if (resultToEnglishIndex.hasOwnProperty(i)) {
              isCapitalized = capitalizationMap[resultToEnglishIndex[i]] || false;
            }
  
            // Combine and skip the next word
            result.push(mergeWords(currentWord, nextWord, isCapitalized));
            mergedPositions.add(result.length - 1); // Mark this position as merged
            skipIndices.add(i + 1);
            i++;
            combined = true;
          }
  
          // If no combination happened, add the word as is
          if (!combined) {
            result.push(currentWord);
          }
        } else {
          // Not a mergable word, add as is if not already combined
          if (!combined) {
            result.push(currentWord);
          }
        }
  
        i++;
      }
  
      return result.join(" ");
    }

    // Helper function to merge words handling vowel overrides
    function mergeWords(word1, word2, isFirstCapitalized, atJunction = true) {
      // Check if we need to handle duplicate letters at junction
      if (atJunction && word1.length > 0 && word2.length > 0 &&
        word1[word1.length - 1].toLowerCase() === word2[0].toLowerCase()) {
        return word1 + word2.substring(1);
      }

      // Get base vowels (without diacritics)
      const vowels = ["a", "e", "i", "o", "u"];
      const vowelMap = {
        "a": ["á", "à", "â", "ä"],
        "e": ["é", "è", "ê", "ë"],
        "i": ["í", "ì", "î", "ï"],
        "o": ["ó", "ò", "ô", "ö"],
        "u": ["ú", "ù", "û", "ü"]
      };

      // Create a reverse lookup from accented vowel to base vowel
      const accentedToBase = {};
      for (const base in vowelMap) {
        for (const accented of vowelMap[base]) {
          accentedToBase[accented] = base;
        }
      }

      // Check junction point for vowel clash
      if (word1.length > 0 && word2.length > 0) {
        const lastChar = word1[word1.length - 1].toLowerCase();
        const firstChar = word2[0].toLowerCase();

        // Check if there's a vowel clash
        const isLastVowel = vowels.includes(lastChar) || accentedToBase.hasOwnProperty(lastChar);
        const isFirstVowel = vowels.includes(firstChar) || accentedToBase.hasOwnProperty(firstChar);

        if (isLastVowel && isFirstVowel) {
          // Determine which vowel to use based on priority and English capitalization
          let useSecondVowel = true;

          // If the first word corresponds to a capitalized English word, preserve its vowel
          if (isFirstCapitalized) {
            useSecondVowel = false;
          }

          if (useSecondVowel) {
            // Use the second word's vowel (possibly with diacritics)
            return word1.substring(0, word1.length - 1) + word2;
          } else {
            // Use the first word's vowel (possibly with diacritics)
            return word1 + word2.substring(1);
          }
        }
      }

      if (word1.length > 0 && word2.length > 0 &&
        word1[word1.length - 1].toLowerCase() === word2[0].toLowerCase()) {
        // Remove the duplicate letter
        return word1 + word2.substring(1);
      }

      return word1 + word2;
    }

    // Function to remove diacritics from Ichrolic text
    function removeDiacritics(text) {
      if (!text) return text;

      // Map of characters with diacritics to their base form
      const diacriticMap = {
        "í": "i", "é": "e", "á": "a", "ó": "o", "ú": "u",
        "ì": "i", "è": "e", "à": "a", "ò": "o", "ù": "u",
        "î": "i", "ê": "e", "â": "a", "ô": "o", "û": "u",
        "ï": "i", "ë": "e", "ä": "a", "ö": "o", "ü": "u"
      };

      let result = text;
      for (const diacritic in diacriticMap) {
        result = result.split(diacritic).join(diacriticMap[diacritic]);
      }

      return result;
    }

    // Dictionary update functionality
    async function handleDictionaryUpdate() {
      if (!githubToken || !currentUser) {
        alert('Please sign in first to update the dictionary');
        return;
      }

      // Show loading state
      saveDictionaryButton.classList.add('loading');
      saveDictionaryButton.disabled = true;
      dictionaryStatus.textContent = "Checking for changes...";

      try {
        // Fetch current dictionary from GitHub API (for SHA)
        const githubDict = await fetchCurrentDictionary();
        
        // Decode the content using proper UTF-8 handling
        const githubContentRaw = atob(githubDict.content);
        // Convert to Uint8Array and then decode as UTF-8
        const bytes = new Uint8Array(githubContentRaw.length);
        for (let i = 0; i < githubContentRaw.length; i++) {
          bytes[i] = githubContentRaw.charCodeAt(i);
        }
        const githubContentString = new TextDecoder('utf-8').decode(bytes);
        const githubContent = JSON.parse(githubContentString);

        // Prepare local dictionary for comparison
        const localContent = {
          dictionary: {},
          synonyms: {}
        };

        // Sort local dictionaries exactly like GitHub version
        const sortedKeys = Object.keys(dictionary).sort();
        for (const key of sortedKeys) {
          localContent.dictionary[key] = dictionary[key];
        }

        const sortedSynKeys = Object.keys(synonyms).sort();
        for (const key of sortedSynKeys) {
          localContent.synonyms[key] = synonyms[key];
        }

        console.log('Comparing dictionaries...');
        console.log('GitHub dictionary entries:', Object.keys(githubContent.dictionary || {}).length);
        console.log('GitHub synonym entries:', Object.keys(githubContent.synonyms || {}).length);
        console.log('Local dictionary entries:', Object.keys(localContent.dictionary).length);
        console.log('Local synonym entries:', Object.keys(localContent.synonyms).length);
        
        // Log sample entries to check UTF-8 handling
        const githubDictKeys = Object.keys(githubContent.dictionary || {}).slice(0, 3);
        const localDictKeys = Object.keys(localContent.dictionary).slice(0, 3);
        console.log('Sample GitHub entries:', githubDictKeys.map(k => `${k}: ${githubContent.dictionary[k]}`));
        console.log('Sample Local entries:', localDictKeys.map(k => `${k}: ${localContent.dictionary[k]}`));

        // Simple comparison - if the counts are different, definitely need to update
        const githubDictCount = Object.keys(githubContent.dictionary || {}).length;
        const githubSynCount = Object.keys(githubContent.synonyms || {}).length;
        const localDictCount = Object.keys(localContent.dictionary).length;
        const localSynCount = Object.keys(localContent.synonyms).length;

        if (githubDictCount !== localDictCount || githubSynCount !== localSynCount) {
          console.log('Count mismatch detected - updating...');
        } else if (forceSyncCheckbox.checked) {
          console.log('Force sync enabled - updating...');
        } else {
          // Counts match, do deep comparison with proper UTF-8
          const normalizeForComparison = (obj) => JSON.stringify(obj, Object.keys(obj).sort());
          const githubNormalized = normalizeForComparison(githubContent);
          const localNormalized = normalizeForComparison(localContent);

          if (githubNormalized === localNormalized) {
            dictionaryStatus.textContent = "Dictionary is already up to date! No changes detected.";
            setTimeout(() => {
              dictionaryStatus.textContent = "";
            }, 3000);
            return;
          } else {
            console.log('Content differences detected - updating...');
          }
        }

        // Dictionaries are different, update GitHub
        dictionaryStatus.textContent = "Updating dictionary on GitHub...";
        
        const updateResult = await updateDictionaryOnGitHub(localContent, githubDict.sha);

        dictionaryStatus.textContent = `Dictionary updated successfully! Commit: ${updateResult.commit.sha.substring(0, 7)}`;
        setTimeout(() => {
          dictionaryStatus.textContent = "";
        }, 5000);

      } catch (error) {
        console.error('Dictionary update error:', error);
        dictionaryStatus.textContent = `Update failed: ${error.message}`;
        setTimeout(() => {
          dictionaryStatus.textContent = "";
        }, 5000);
      } finally {
        saveDictionaryButton.classList.remove('loading');
        saveDictionaryButton.disabled = false;
      }
    }

    // Modified save dictionary function to handle both modes
    function saveDictionary() {
      if (isDeveloperMode && githubToken) {
        // Developer mode with GitHub token - update repository
        handleDictionaryUpdate();
      } else {
        // Normal mode - download file
        saveLocalDictionary();
      }
    }

    // Renamed original save function
    function saveLocalDictionary() {
      try {
        // Create sorted copies of the dictionaries
        const sortedDictionary = {};
        const sortedKeys = Object.keys(dictionary).sort();
        for (const key of sortedKeys) {
          sortedDictionary[key] = dictionary[key];
        }

        const sortedSynonyms = {};
        const sortedSynKeys = Object.keys(synonyms).sort();
        for (const key of sortedSynKeys) {
          sortedSynonyms[key] = synonyms[key];
        }

        // Create the data structure to save
        const saveData = {
          dictionary: sortedDictionary,
          synonyms: sortedSynonyms
        };

        // Convert to JSON
        const jsonString = JSON.stringify(saveData, null, 2);

        // Create a blob and download link
        const blob = new Blob([jsonString], {type: 'application/json'});
        const url = URL.createObjectURL(blob);

        // Create a temporary download link
        const downloadLink = document.createElement('a');
        downloadLink.href = url;
        downloadLink.download = 'ichrolic_dictionary.json';

        // Append to body, click, and remove
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);

        // Release the object URL
        URL.revokeObjectURL(url);

        dictionaryStatus.textContent = "Dictionary saved successfully to file.";

        // Clear status message after 3 seconds
        setTimeout(() => {
          dictionaryStatus.textContent = "";
        }, 3000);
      } catch (error) {
        dictionaryStatus.textContent = "Error saving dictionary: " + error.message;
      }
    }

    // Toggle dictionary table visibility
    function toggleDictionaryTable() {
      if (dictionaryTable.style.display === "none") {
        dictionaryTable.style.display = "block";
        updateDictionaryTable();
      } else {
        dictionaryTable.style.display = "none";
      }
    }

    // Dictionary sorting parameters
    let currentSortField = 'english'; // Default sort by English
    let sortDirection = 'asc'; // Default sort direction

    // Function to toggle sort direction and field
    function sortDictionary(field) {
      if (currentSortField === field) {
        // Toggle direction if clicking same field
        sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        // Set new field and reset direction to ascending
        currentSortField = field;
        sortDirection = 'asc';
      }

      updateSortIndicators();
      updateDictionaryTable();
    }

    // Function to update sort indicators in table headers
    function updateSortIndicators() {
      // Update the English header
      englishHeader.innerHTML = "English";
      if (currentSortField === 'english') {
        englishHeader.innerHTML += ` <span class="sort-indicator">${sortDirection === 'asc' ? '▲' : '▼'}</span>`;
      }

      // Update the Ichrolic header
      ichrolicHeader.innerHTML = "Ichrolic";
      if (currentSortField === 'ichrolic') {
        ichrolicHeader.innerHTML += ` <span class="sort-indicator">${sortDirection === 'asc' ? '▲' : '▼'}</span>`;
      }
    }
  </script>
</body>
</html>
