<!DOCTYPE html>
<html lang="en" class="dark-mode">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Ichrolic Translator</title>
	<style>
		:root {
			--bg-color: #f5f5f5;
			--container-bg: white;
			--text-color: #333;
			--heading-color: #3a506b;
			--border-color: #ccc;
			--button-bg: #3a506b;
			--button-text: white;
			--button-hover: #1c2541;
			--settings-bg: #f9f9f9;
			--table-header-bg: #f2f2f2;
			--table-border: #ddd;
			--table-hover: #f9f9f9;
			--synonym-row-bg: #f0f8ff;
			--synonym-row-hover: #e6f2ff;
			--box-shadow: rgba(0, 0, 0, 0.1);
		}

		html.dark-mode {
			--bg-color: #1e1e1e;
			--container-bg: #2d2d2d;
			--text-color: #e0e0e0;
			--heading-color: #7dbe90;
			--border-color: #444;
			--button-bg: #7dbe90;
			--button-text: #193b27;
			--button-hover: #7dbe90;
			--settings-bg: #383838;
			--table-header-bg: #3b4252;
			--table-border: #555;
			--table-hover: #3b4252;
			--synonym-row-bg: #2c303f;
			--synonym-row-hover: #434c5e;
			--box-shadow: rgba(0, 0, 0, 0.3);
		}

		body {
			font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
			background-color: var(--bg-color);
			color: var(--text-color);
			padding: 20px;
			max-width: 900px;
			margin: 0 auto;
			transition: background-color 0.3s ease, color 0.3s ease;
		}

		.container {
			background-color: var(--container-bg);
			border-radius: 10px;
			box-shadow: 0 4px 8px var(--box-shadow);
			padding: 20px;
			position: relative;
		}

		/* Developer mode dropdown styles */
		.dev-menu {
			position: absolute;
			top: 20px;
			left: 20px;
			display: none;
		}

		.dev-menu.show {
			display: block;
		}

		.dev-menu-toggle {
			background-color: var(--button-bg);
			color: var(--button-text);
			border: none;
			padding: 8px 12px;
			border-radius: 5px;
			cursor: pointer;
			font-size: 18px;
			line-height: 1;
		}

		.dev-menu-toggle.dev-mode {
			background-color: #808080;
			color: white;
		}

		.dev-menu-toggle:hover {
			background-color: var(--button-hover);
		}

		.dev-menu-toggle.dev-mode:hover {
			background-color: #696969;
		}

		.dev-menu-dropdown {
			position: absolute;
			top: 100%;
			left: 0;
			margin-top: 5px;
			background-color: var(--container-bg);
			border: 1px solid var(--border-color);
			border-radius: 5px;
			box-shadow: 0 4px 8px var(--box-shadow);
			min-width: 120px;
			z-index: 1000;
			display: none;
		}

		.dev-menu-dropdown.show {
			display: block;
		}

		.dev-menu-item {
			padding: 10px 15px;
			cursor: pointer;
			border-bottom: 1px solid var(--border-color);
			transition: background-color 0.2s ease;
		}

		.dev-menu-item:last-child {
			border-bottom: none;
		}

		.dev-menu-item:hover {
			background-color: var(--table-hover);
		}

		/* Sign-in modal styles */
		.modal-overlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(0, 0, 0, 0.5);
			display: none;
			justify-content: center;
			align-items: center;
			z-index: 2000;
		}

		.modal-overlay.show {
			display: flex;
		}

		.modal {
			background-color: var(--container-bg);
			border-radius: 10px;
			box-shadow: 0 8px 16px var(--box-shadow);
			padding: 30px;
			max-width: 500px;
			width: 90%;
			max-height: 80vh;
			overflow-y: auto;
		}

		.modal h2 {
			color: var(--heading-color);
			margin-bottom: 20px;
			text-align: center;
		}

		.modal p {
			margin-bottom: 15px;
			line-height: 1.5;
		}

		.modal input {
			width: 100%;
			padding: 10px;
			border: 1px solid var(--border-color);
			border-radius: 5px;
			margin-bottom: 15px;
			font-family: inherit;
			background-color: var(--container-bg) !important;
			color: var(--text-color) !important;
			-webkit-text-fill-color: var(--text-color);
		}

		.modal-buttons {
			display: flex;
			gap: 10px;
			justify-content: flex-end;
		}

		.modal-buttons button {
			padding: 10px 20px;
		}

		.modal a {
			color: var(--heading-color);
			text-decoration: none;
		}

		.modal a:hover {
			text-decoration: underline;
		}

		.cancel-button {
			background-color: #6c757d;
			color: white;
		}

		.cancel-button:hover {
			background-color: #5a6268;
		}

		/* Loading state for buttons */
		.loading {
			opacity: 0.6;
			cursor: not-allowed;
			position: relative;
		}

		.loading:after {
			content: '';
			position: absolute;
			width: 16px;
			height: 16px;
			margin: auto;
			border: 2px solid transparent;
			border-top-color: currentColor;
			border-radius: 50%;
			animation: spin 1s linear infinite;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
		}

		@keyframes spin {
			0% { transform: translate(-50%, -50%) rotate(0deg); }
			100% { transform: translate(-50%, -50%) rotate(360deg); }
		}

		/* Signed in indicator */
		.signed-in-indicator {
			color: #28a745;
			font-size: 12px;
			margin-left: 5px;
		}

		/* Goldenrod button style for developer mode */
		.goldenrod-button {
			background-color: #DAA520 !important;
			color: #8B4513 !important;
		}

		.goldenrod-button:hover {
			background-color: #B8860B !important;
		}
		h1 {
			color: var(--heading-color);
			text-align: center;
			margin-bottom: 30px;
			transition: margin-left 0.3s ease;
		}

		h1.dev-mode {
			margin-left: 60px; /* Make room for dev menu only in dev mode */
		}
		.translator {
			display: flex;
			flex-direction: column;
			gap: 20px;
		}
		.text-areas {
			display: flex;
			gap: 20px;
		}
		@media (max-width: 768px) {
			.text-areas {
				flex-direction: column;
			}
		}
		.text-column {
			flex: 1;
			display: flex;
			flex-direction: column;
		}
		.header {
			font-weight: bold;
			margin-bottom: 5px;
		}
		/* Complete text area styling with focus states */
		textarea {
			height: 200px;
			padding: 10px;
			border: 1px solid var(--border-color);
			border-radius: 5px;
			resize: none;
			font-size: 16px;
			font-family: inherit;
			background-color: var(--container-bg) !important;
			color: var(--text-color) !important; /* Force text color */
			transition: border-color 0.2s ease, outline-color 0.2s ease;
			-webkit-text-fill-color: var(--text-color); /* For WebKit browsers */
		}

		textarea:focus {
			background-color: var(--container-bg) !important; /* Force override */
			color: var(--text-color) !important; /* Force override */
			border-color: var(--heading-color);
			outline: 1px solid var(--heading-color);
			outline-offset: -1px; /* Keep outline tight to the border */
			-webkit-text-fill-color: var(--text-color); /* For WebKit browsers */
		}

		/* For webkit browsers like Chrome/Safari */
		textarea:focus-visible {
			background-color: var(--container-bg) !important;
			color: var(--text-color) !important;
			-webkit-text-fill-color: var(--text-color);
		}
		
		/* Fix for Firefox */
		textarea:-moz-ui-invalid {
			box-shadow: none;
		}
		
		/* Force text color for all input states */
		textarea:active, textarea:hover, textarea:focus {
			color: var(--text-color) !important;
		}

		/* Special styling for the Ichrolic output textarea */
		#ichrolicOutput {
			cursor: pointer;
			user-select: none;
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			position: relative;
			transition: all 0.2s ease;
		}

		#ichrolicOutput:hover {
			background-color: var(--table-hover) !important;
			border-color: var(--heading-color);
		}

		/* Copy feedback styling */
		.copy-feedback {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			background-color: var(--heading-color);
			color: var(--button-text);
			padding: 8px 16px;
			border-radius: 20px;
			font-size: 14px;
			font-weight: bold;
			opacity: 0;
			pointer-events: none;
			transition: opacity 0.3s ease;
			z-index: 100;
		}

		.copy-feedback.show {
			opacity: 1;
		}

		.settings {
			background-color: var(--settings-bg);
			padding: 15px;
			border-radius: 5px;
			margin-bottom: 20px;
		}
		.settings-header {
			font-weight: bold;
			margin-bottom: 10px;
		}
		.setting {
			margin-bottom: 10px;
			display: flex;
			align-items: center;
		}
		.setting label {
			margin-left: 8px;
		}
		.dictionary-controls {
			margin-top: 20px;
			display: flex;
			gap: 10px;
			flex-wrap: wrap;
		}
		.dictionary-status {
			margin-top: 10px;
			font-style: italic;
			color: #666;
		}
		html.dark-mode .dictionary-status {
			color: #aaa;
		}
		.add-entry #synonymToggle {
			padding: 5px 10px;
			background-color: #6c757d;
			min-width: 40px;
		}
		button {
			background-color: var(--button-bg);
			color: var(--button-text);
			border: none;
			padding: 8px 15px;
			border-radius: 5px;
			cursor: pointer;
			font-size: 14px;
		}
		button:hover {
			background-color: var(--button-hover);
		}
		.dictionary-table {
			margin-top: 20px;
			max-height: 300px;
			overflow-y: auto;
			border: 1px solid var(--table-border);
			border-radius: 5px;
		}
		.dictionary-search {
			margin-bottom: 15px;
			width: 100%;
			display: flex;
			align-items: center;
			gap: 10px;
		}
		.dictionary-search input {
			flex: 1;
			padding: 8px;
			border: 1px solid var(--border-color);
			border-radius: 5px;
			background-color: var(--container-bg) !important;
			color: var(--text-color) !important;
			-webkit-text-fill-color: var(--text-color);
		}
		
		/* Fix for all input elements */
		input[type="text"] {
			background-color: var(--container-bg) !important;
			color: var(--text-color) !important;
			-webkit-text-fill-color: var(--text-color);
		}
		
		input[type="text"]:focus, input[type="text"]:active, input[type="text"]:hover {
			background-color: var(--container-bg) !important;
			color: var(--text-color) !important;
			-webkit-text-fill-color: var(--text-color);
		}
		.dictionary-search .setting {
			margin-bottom: 0;
			white-space: nowrap;
			padding-right: 8px;
		}
		.dictionary-fixed-header {
			position: sticky;
			top: 0;
			background-color: var(--container-bg);
			padding: 15px 0;
			z-index: 10;
			border-bottom: 1px solid var(--border-color);
		}
		
		/* Mobile-friendly table styles */
		.table-responsive {
			overflow-x: auto;
			width: 100%;
		}
		
		@media (max-width: 768px) {
			.table-container {
				margin: 0 -15px; /* Negative margin to allow full-width scrolling */
				overflow-x: auto;
				-webkit-overflow-scrolling: touch;
			}
			
			.mobile-table {
				display: flex;
				flex-direction: column;
				margin-top: 15px;
			}
			
			.mobile-table-entry {
				border: 1px solid var(--table-border);
				border-radius: 5px;
				margin-bottom: 10px;
				padding: 10px;
				background-color: var(--container-bg);
			}
			
			.mobile-table-entry.synonym-row {
				background-color: var(--synonym-row-bg);
			}
			
			.mobile-table-row {
				display: flex;
				justify-content: space-between;
				margin-bottom: 5px;
				flex-wrap: wrap;
			}
			
			.mobile-table-label {
				font-weight: bold;
				margin-right: 10px;
				min-width: 70px;
			}
			
			.mobile-table-actions {
				display: flex;
				gap: 5px;
				margin-top: 10px;
				flex-wrap: wrap;
			}
		}
		
		/* Regular table for larger screens */
		@media (min-width: 769px) {
			table {
				width: 100%;
				border-collapse: collapse;
			}
			th, td {
				padding: 8px 12px;
				text-align: left;
				border-bottom: 1px solid var(--table-border);
			}
			th {
				background-color: var(--table-header-bg);
				color: var(--text-color);
				position: sticky;
				top: 0;
			}
			tr:hover {
				background-color: var(--table-hover);
			}
			tr.synonym-row {
				background-color: var(--synonym-row-bg);
			}
			tr.synonym-row:hover {
				background-color: var(--synonym-row-hover);
			}
			.mobile-table {
				display: none;
			}
		}
		
		.add-entry {
			margin-top: 20px;
			display: flex;
			gap: 10px;
			flex-wrap: wrap;
		}
		.add-entry input {
			flex: 1;
			padding: 8px;
			border: 1px solid var(--border-color);
			border-radius: 5px;
			background-color: var(--container-bg) !important;
			color: var(--text-color) !important;
			-webkit-text-fill-color: var(--text-color);
		}
		.empty-dictionary {
			padding: 20px;
			text-align: center;
			color: #666;
			font-style: italic;
		}
		html.dark-mode .empty-dictionary {
			color: #aaa;
		}
		.sort-indicator {
			display: inline-block;
		}
		
		/* Dark mode toggle styles */
		.dark-mode-toggle {
			position: absolute;
			top: 20px;
			right: 20px;
			display: flex;
			align-items: center;
			gap: 10px;
		}
		
		@media (max-width: 422px) {
			.dark-mode-toggle {
				top: 15px;
				right: 15px;
			}
			
			.mode-toggle-emoji {
				cursor: pointer;
				font-size: 24px;
				line-height: 1;
				display: block;
			}
			
			.toggle-switch, .mode-icon {
				display: none !important;
			}
		}
		
		@media (min-width: 423px) {
			.mode-toggle-emoji {
				display: none;
			}
		}
		
		.toggle-switch {
			position: relative;
			display: inline-block;
			width: 60px;
			height: 30px;
		}
		.toggle-switch input {
			opacity: 0;
			width: 0;
			height: 0;
		}
		.toggle-slider {
			position: absolute;
			cursor: pointer;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background-color: #ccc;
			transition: .4s;
			border-radius: 34px;
		}
		.toggle-slider:before {
			position: absolute;
			content: "";
			height: 22px;
			width: 22px;
			left: 4px;
			bottom: 4px;
			background-color: white;
			transition: .4s;
			border-radius: 50%;
		}
		input:checked + .toggle-slider {
			background-color: #7dbe90;
		}
		input:checked + .toggle-slider:before {
			transform: translateX(30px);
		}
		.mode-icon {
			font-size: 20px;
		}
		
		/* Mobile title and layout improvements */
		@media (max-width: 768px) {
			h1 {
				text-align: left;
				font-size: 1.5rem; /* Smaller size on mobile */
				margin-bottom: 10px;
				margin-right: 10px; /* Make space for the toggle switch */
			}

			h1.dev-mode {
				margin-left: 60px; /* Keep space for dev menu on mobile too when in dev mode */
			}

			.dark-mode-toggle {
				top: 30px; /* Align with the title */
			}

			.container {
				padding: 15px; /* Slightly reduce padding on mobile */
			}
			
			.dictionary-controls {
				justify-content: space-between;
			}
			
			.dictionary-controls button {
				flex-grow: 1;
				text-align: center;
			}
			
			.add-entry {
				flex-direction: column;
			}
			
			.add-entry input {
				width: 100%;
			}
			
			#synonymToggle {
				align-self: flex-start;
			}
		}
	</style>
</head>
<body>
	<div class="container">
		<!-- Developer mode menu -->
		<div class="dev-menu" id="devMenu">
			<button class="dev-menu-toggle" id="devMenuToggle">⋯</button>
			<div class="dev-menu-dropdown" id="devMenuDropdown">
				<div class="dev-menu-item" id="devSignIn">
					<span id="signInText">Sign In</span>
					<span class="signed-in-indicator" id="signedInIndicator" style="display: none;">✓</span>
				</div>
				<div class="dev-menu-item" id="devClose">Close</div>
			</div>
		</div>

		<!-- Sign-in modal -->
		<div class="modal-overlay" id="signInModal">
			<div class="modal">
				<h2>Developer Sign In</h2>
				<p>Enter your GitHub Personal Access Token to enable dictionary updates.</p>
				<p><strong>Required permissions:</strong> Contents, Metadata</p>
				<p><a href="https://github.com/settings/tokens/new?scopes=repo" target="_blank">Create a new token →</a></p>
				<input type="password" id="tokenInput" placeholder="ghp_xxxxxxxxxxxxxxxxxxxx" />
				<div class="modal-buttons">
					<button class="cancel-button" id="cancelSignIn">Cancel</button>
					<button id="confirmSignIn">Sign In</button>
				</div>
			</div>
		</div>

		<h1 id="pageTitle">Ichrolic Translator</h1>

		<div class="dark-mode-toggle">
			<span class="mode-icon">☀️</span>
			<label class="toggle-switch">
				<input type="checkbox" id="darkModeToggle" checked>
				<span class="toggle-slider"></span>
			</label>
			<span class="mode-icon">🌙</span>
			<!-- Added emoji toggle for smaller screens -->
			<span class="mode-toggle-emoji" id="modeToggleEmoji">🌙</span>
		</div>

		<div class="settings">
			<div class="settings-header">Settings</div>
			<div class="setting">
				<input type="checkbox" id="ignoreDiacritics">
				<label for="ignoreDiacritics">Ignore Diacritics</label>
			</div>
			<div class="setting">
				<input type="checkbox" id="useContractions" checked>
				<label for="useContractions">Use Contractions</label>
			</div>
		</div>

		<div class="translator">
			<div class="text-areas">
				<div class="text-column">
					<div class="header">English</div>
					<textarea id="englishInput" placeholder="Enter English text here..."></textarea>
				</div>
				<div class="text-column" style="position: relative;">
					<div class="header">Ichrolic (Click to Copy)</div>
					<textarea id="ichrolicOutput" placeholder="Ichrolic translation will appear here..." readonly title="Click to copy to clipboard"></textarea>
					<div class="copy-feedback" id="copyFeedback">Copied! ✓</div>
				</div>
			</div>
		</div>

		<div class="dictionary-controls">
			<button id="saveDictionary">Save Dictionary</button>
			<button id="showDictionary">Show/Hide Dictionary</button>
		</div>
		<div class="dictionary-status" id="dictionaryStatus"></div>

		<div class="dictionary-table" id="dictionaryTable" style="display: none;">
			<div class="dictionary-search">
				<input type="text" id="dictionarySearchInput" placeholder="Search dictionary...">
				<div class="setting">
					<input type="checkbox" id="showSynonyms" checked>
					<label for="showSynonyms">Show Synonyms</label>
				</div>
			</div>

			<div class="add-entry">
				<input type="text" id="newEnglish" placeholder="English word or phrase">
				<button id="synonymToggle" title="Toggle between direct translation and synonym">=</button>
				<input type="text" id="newIchrolic" placeholder="Ichrolic translation">
				<button id="addEntry">Add Entry</button>
			</div>

			<!-- Regular table for desktop view -->
			<div class="table-container">
				<table id="desktopTable">
					<thead>
						<tr>
							<th id="englishHeader">English</th>
							<th id="ichrolicHeader">Ichrolic</th>
							<th>Actions</th>
						</tr>
					</thead>
					<tbody id="dictionaryBody">
						<!-- Dictionary entries will be added here -->
					</tbody>
				</table>
			</div>
			
			<!-- Mobile-friendly table layout -->
			<div class="mobile-table" id="mobileTable">
				<!-- Mobile entries will be added here -->
			</div>

			<div id="emptyDictionary" class="empty-dictionary">
				No dictionary entries yet. Add some above!
			</div>
		</div>
	</div>

	<script>
		// Dark mode functionality
		const darkModeToggle = document.getElementById('darkModeToggle');
		const modeToggleEmoji = document.getElementById('modeToggleEmoji');
		const htmlElement = document.documentElement;

		// Function to toggle dark mode
		function toggleDarkMode() {
			htmlElement.classList.toggle('dark-mode');
			localStorage.setItem('darkMode', htmlElement.classList.contains('dark-mode'));
			
			// Update the emoji for small screens
			if (htmlElement.classList.contains('dark-mode')) {
				modeToggleEmoji.textContent = '🌙';
			} else {
				modeToggleEmoji.textContent = '☀️';
			}
		}

		// Event listener for the toggle switch
		darkModeToggle.addEventListener('change', toggleDarkMode);
		
		// Event listener for the emoji toggle (for mobile)
		modeToggleEmoji.addEventListener('click', function() {
			darkModeToggle.checked = !darkModeToggle.checked;
			toggleDarkMode();
		});

		// Set initial state (dark mode by default)
		// We've already added the 'dark-mode' class to the html element

		// Main dictionary and synonyms objects
		let dictionary = {};
		let synonyms = {};

		// DOM Elements
		const synonymToggleButton = document.getElementById('synonymToggle');
		const englishInput = document.getElementById('englishInput');
		const ichrolicOutput = document.getElementById('ichrolicOutput');
		const ignoreDiacriticsCheckbox = document.getElementById('ignoreDiacritics');
		const useContractionsCheckbox = document.getElementById('useContractions');
		const saveDictionaryButton = document.getElementById('saveDictionary');
		const showDictionaryButton = document.getElementById('showDictionary');
		const dictionaryStatus = document.getElementById('dictionaryStatus');
		const dictionaryTable = document.getElementById('dictionaryTable');
		const dictionaryBody = document.getElementById('dictionaryBody');
		const mobileTable = document.getElementById('mobileTable');
		const newEnglishInput = document.getElementById('newEnglish');
		const newIchrolicInput = document.getElementById('newIchrolic');
		const addEntryButton = document.getElementById('addEntry');
		const dictionarySearchInput = document.getElementById('dictionarySearchInput');
		const showSynonymsCheckbox = document.getElementById('showSynonyms');
		const englishHeader = document.getElementById('englishHeader');
		const ichrolicHeader = document.getElementById('ichrolicHeader');
		const copyFeedback = document.getElementById('copyFeedback');

		// Developer mode elements
		const pageTitle = document.getElementById('pageTitle');
		const devMenu = document.getElementById('devMenu');
		const devMenuToggle = document.getElementById('devMenuToggle');
		const devMenuDropdown = document.getElementById('devMenuDropdown');
		const devSignIn = document.getElementById('devSignIn');
		const devClose = document.getElementById('devClose');
		const signInText = document.getElementById('signInText');
		const signedInIndicator = document.getElementById('signedInIndicator');
		const signInModal = document.getElementById('signInModal');
		const tokenInput = document.getElementById('tokenInput');
		const confirmSignIn = document.getElementById('confirmSignIn');
		const cancelSignIn = document.getElementById('cancelSignIn');

		let isSynonymMode = false; // Track the current mode
		let isDeveloperMode = false; // Track developer mode
		let githubToken = localStorage.getItem('github_token'); // GitHub token
		let currentUser = null; // Store user info

		// Copy to clipboard functionality
		ichrolicOutput.addEventListener('click', function() {
			const text = ichrolicOutput.value;
			if (text.trim() === '') {
				return; // Don't copy if there's no text
			}

			// Use the modern clipboard API if available
			if (navigator.clipboard && navigator.clipboard.writeText) {
				navigator.clipboard.writeText(text).then(function() {
					showCopyFeedback();
				}).catch(function() {
					// Fallback to the older method
					fallbackCopyTextToClipboard(text);
				});
			} else {
				// Fallback for older browsers
				fallbackCopyTextToClipboard(text);
			}
		});

		// Fallback copy method for older browsers
		function fallbackCopyTextToClipboard(text) {
			const textArea = document.createElement("textarea");
			textArea.value = text;
			
			// Avoid scrolling to bottom
			textArea.style.top = "0";
			textArea.style.left = "0";
			textArea.style.position = "fixed";

			document.body.appendChild(textArea);
			textArea.focus();
			textArea.select();

			try {
				const successful = document.execCommand('copy');
				if (successful) {
					showCopyFeedback();
				}
			} catch (err) {
				console.error('Fallback: Oops, unable to copy', err);
			}

			document.body.removeChild(textArea);
		}

		// Show copy feedback animation
		function showCopyFeedback() {
			copyFeedback.classList.add('show');
			setTimeout(() => {
				copyFeedback.classList.remove('show');
			}, 1500);
		}

		// Developer mode functionality
		function enterDeveloperMode() {
			isDeveloperMode = true;
			
			// Add dev mode class to title and dev menu toggle
			pageTitle.classList.add('dev-mode');
			devMenuToggle.classList.add('dev-mode');
			
			// Change title based on screen size
			updateDeveloperTitle();
			
			// Show developer menu
			devMenu.classList.add('show');
			
			// Change save button text and style
			saveDictionaryButton.textContent = 'Update Dictionary';
			saveDictionaryButton.classList.add('goldenrod-button');
			
			// Clear the input field
			englishInput.value = '';
			ichrolicOutput.value = '';
		}

		function exitDeveloperMode() {
			isDeveloperMode = false;
			
			// Remove dev mode classes
			pageTitle.classList.remove('dev-mode');
			devMenuToggle.classList.remove('dev-mode');
			
			// Revert title
			pageTitle.textContent = 'Ichrolic Translator';
			
			// Hide developer menu
			devMenu.classList.remove('show');
			devMenuDropdown.classList.remove('show');
			
			// Revert save button text and style
			saveDictionaryButton.textContent = 'Save Dictionary';
			saveDictionaryButton.classList.remove('goldenrod-button');
		}

		function updateDeveloperTitle() {
			if (isDeveloperMode) {
				// Check if we're in mobile view (where emoji toggle is visible)
				if (window.innerWidth <= 422) {
					pageTitle.textContent = ';)';
				} else {
					pageTitle.textContent = 'Ichrolic Editor';
				}
			}
		}

		// Update title on window resize if in developer mode
		window.addEventListener('resize', function() {
			updateDeveloperTitle();
			updateDictionaryTable();
		});

		// Developer menu toggle
		devMenuToggle.addEventListener('click', function(e) {
			e.stopPropagation();
			devMenuDropdown.classList.toggle('show');
		});

		// Close dropdown when clicking outside
		document.addEventListener('click', function() {
			devMenuDropdown.classList.remove('show');
		});

		// Developer menu item event handlers
		devSignIn.addEventListener('click', function() {
			if (githubToken && currentUser) {
				// Already signed in, offer to sign out
				if (confirm(`Sign out from ${currentUser.login}?`)) {
					handleSignOut();
				}
			} else {
				// Not signed in, show sign in modal
				showSignInModal();
			}
			devMenuDropdown.classList.remove('show');
		});

		devClose.addEventListener('click', function() {
			exitDeveloperMode();
			devMenuDropdown.classList.remove('show');
		});

		// Sign-in modal event listeners
		confirmSignIn.addEventListener('click', handleSignIn);
		cancelSignIn.addEventListener('click', hideSignInModal);

		// Close modal when clicking outside
		signInModal.addEventListener('click', function(e) {
			if (e.target === signInModal) {
				hideSignInModal();
			}
		});

		// Handle Enter key in token input
		tokenInput.addEventListener('keypress', function(e) {
			if (e.key === 'Enter') {
				handleSignIn();
			}
		});

		// Check for developer mode trigger
		englishInput.addEventListener('input', function() {
			if (englishInput.value === '/////') {
				enterDeveloperMode();
			}
		});
		function isMobileView() {
			return window.innerWidth <= 768;
		}



		// Event Listeners
		englishInput.addEventListener('input', translateToIchrolic);
		ignoreDiacriticsCheckbox.addEventListener('change', translateToIchrolic);
		useContractionsCheckbox.addEventListener('change', translateToIchrolic);
		saveDictionaryButton.addEventListener('click', saveDictionary);
		showDictionaryButton.addEventListener('click', toggleDictionaryTable);
		addEntryButton.addEventListener('click', addDictionaryEntry);
		dictionarySearchInput.addEventListener('input', updateDictionaryTable);
		showSynonymsCheckbox.addEventListener('change', updateDictionaryTable);
		englishHeader.addEventListener('click', () => sortDictionary('english'));
		ichrolicHeader.addEventListener('click', () => sortDictionary('ichrolic'));
		synonymToggleButton.addEventListener('click', toggleSynonymMode);

		// GitHub API functions
		async function testGitHubToken(token) {
			try {
				const response = await fetch('https://api.github.com/user', {
					headers: {
						'Authorization': `token ${token}`,
						'Accept': 'application/vnd.github.v3+json'
					}
				});
				
				if (response.ok) {
					return await response.json();
				} else {
					throw new Error(`GitHub API error: ${response.status}`);
				}
			} catch (error) {
				throw new Error(`Failed to verify token: ${error.message}`);
			}
		}

		async function fetchCurrentDictionary() {
			try {
				const response = await fetch('https://api.github.com/repos/AltoneInteractive/AltoneInteractive.github.io/contents/dictionary.json', {
					headers: {
						'Authorization': `token ${githubToken}`,
						'Accept': 'application/vnd.github.v3+json'
					}
				});
				
				if (response.ok) {
					return await response.json();
				} else {
					throw new Error(`Failed to fetch dictionary: ${response.status}`);
				}
			} catch (error) {
				throw new Error(`GitHub API error: ${error.message}`);
			}
		}

		async function updateDictionaryOnGitHub(newContent, currentSha) {
			try {
				const base64Content = btoa(JSON.stringify(newContent, null, 2));
				
				const response = await fetch('https://api.github.com/repos/AltoneInteractive/AltoneInteractive.github.io/contents/dictionary.json', {
					method: 'PUT',
					headers: {
						'Authorization': `token ${githubToken}`,
						'Accept': 'application/vnd.github.v3+json',
						'Content-Type': 'application/json'
					},
					body: JSON.stringify({
						message: `Update dictionary via Ichrolic Editor - ${new Date().toISOString()}`,
						content: base64Content,
						sha: currentSha
					})
				});
				
				if (response.ok) {
					return await response.json();
				} else {
					throw new Error(`Failed to update dictionary: ${response.status}`);
				}
			} catch (error) {
				throw new Error(`Update failed: ${error.message}`);
			}
		}

		// Sign-in functionality
		function showSignInModal() {
			signInModal.classList.add('show');
			tokenInput.value = '';
			tokenInput.focus();
		}

		function hideSignInModal() {
			signInModal.classList.remove('show');
		}

		function updateSignInState() {
			if (githubToken && currentUser) {
				signInText.textContent = `${currentUser.login}`;
				signedInIndicator.style.display = 'inline';
			} else {
				signInText.textContent = 'Sign In';
				signedInIndicator.style.display = 'none';
			}
		}

		async function handleSignIn() {
			const token = tokenInput.value.trim();
			if (!token) {
				alert('Please enter a GitHub token');
				return;
			}

			// Show loading state
			confirmSignIn.classList.add('loading');
			confirmSignIn.disabled = true;

			try {
				const user = await testGitHubToken(token);
				
				// Store token and user info
				githubToken = token;
				currentUser = user;
				localStorage.setItem('github_token', token);
				localStorage.setItem('github_user', JSON.stringify(user));
				
				updateSignInState();
				hideSignInModal();
				
				dictionaryStatus.textContent = `Signed in as ${user.login}`;
				setTimeout(() => {
					dictionaryStatus.textContent = "";
				}, 3000);
				
			} catch (error) {
				alert(`Sign in failed: ${error.message}`);
			} finally {
				confirmSignIn.classList.remove('loading');
				confirmSignIn.disabled = false;
			}
		}

		function handleSignOut() {
			githubToken = null;
			currentUser = null;
			localStorage.removeItem('github_token');
			localStorage.removeItem('github_user');
			updateSignInState();
			
			dictionaryStatus.textContent = "Signed out";
			setTimeout(() => {
				dictionaryStatus.textContent = "";
			}, 3000);
		}
		function removeDiacriticsForSearch(text) {
			if (!text) return text;

			// Map of characters with diacritics to their base form
			const diacriticMap = {
				"í": "i", "é": "e", "á": "a", "ó": "o", "ú": "u",
				"ì": "i", "è": "e", "à": "a", "ò": "o", "ù": "u",
				"î": "i", "ê": "e", "â": "a", "ô": "o", "û": "u",
				"ï": "i", "ë": "e", "ä": "a", "ö": "o", "ü": "u"
			};

			let result = text.toLowerCase();
			for (const diacritic in diacriticMap) {
				result = result.split(diacritic).join(diacriticMap[diacritic]);
			}

			return result;
		}

		// Function to update the dictionary table
		function updateDictionaryTable() {
			const showSynonyms = showSynonymsCheckbox.checked;
			const searchTerm = dictionarySearchInput.value.toLowerCase();

			// Clear both table views
			dictionaryBody.innerHTML = '';
			mobileTable.innerHTML = '';

			// Get a list of all entries to display
			const entries = [];

			// Add main dictionary entries
			for (const english in dictionary) {
				const normalizedEnglish = removeDiacriticsForSearch(english);
				const normalizedIchrolic = removeDiacriticsForSearch(dictionary[english]);
				const normalizedSearch = removeDiacriticsForSearch(searchTerm);
				
				if (searchTerm === '' ||
					normalizedEnglish.includes(normalizedSearch) ||
					normalizedIchrolic.includes(normalizedSearch)) {
					entries.push({
						english: english,
						ichrolic: dictionary[english],
						isSynonym: false
					});
				}
			}

			// Add synonym entries if enabled
			if (showSynonyms) {
				for (const synonym in synonyms) {
					const canonicalForm = synonyms[synonym];
					if (dictionary.hasOwnProperty(canonicalForm)) {
						const normalizedSynonym = removeDiacriticsForSearch(synonym);
						const normalizedIchrolic = removeDiacriticsForSearch(dictionary[canonicalForm]);
						const normalizedSearch = removeDiacriticsForSearch(searchTerm);
						
						if (searchTerm === '' ||
							normalizedSynonym.includes(normalizedSearch) ||
							normalizedIchrolic.includes(normalizedSearch)) {
							entries.push({
								english: synonym,
								ichrolic: dictionary[canonicalForm],
								isSynonym: true,
								canonicalForm: canonicalForm
							});
						}
					}
				}
			}

			// Sort entries with smart search relevance
			if (searchTerm !== '') {
				// Smart search sorting: exact match -> starts with -> contains
				entries.sort((a, b) => {
					const aEnglish = removeDiacriticsForSearch(a.english);
					const bEnglish = removeDiacriticsForSearch(b.english);
					const aIchrolic = removeDiacriticsForSearch(a.ichrolic);
					const bIchrolic = removeDiacriticsForSearch(b.ichrolic);
					const normalizedSearch = removeDiacriticsForSearch(searchTerm);
					
					// Calculate relevance scores
					const getRelevanceScore = (english, ichrolic) => {
						// Exact match gets highest score
						if (english === normalizedSearch || ichrolic === normalizedSearch) return 100;
						
						// Starts with search term gets high score
						if (english.startsWith(normalizedSearch) || ichrolic.startsWith(normalizedSearch)) return 50;
						
						// Contains search term gets lower score
						if (english.includes(normalizedSearch) || ichrolic.includes(normalizedSearch)) return 10;
						
						return 0;
					};
					
					const scoreA = getRelevanceScore(aEnglish, aIchrolic);
					const scoreB = getRelevanceScore(bEnglish, bIchrolic);
					
					// If scores are different, sort by relevance (higher score first)
					if (scoreA !== scoreB) {
						return scoreB - scoreA;
					}
					
					// If same relevance score, fall back to alphabetical sorting
					const fieldA = currentSortField === 'english' ? aEnglish : aIchrolic;
					const fieldB = currentSortField === 'english' ? bEnglish : bIchrolic;
					
					if (sortDirection === 'asc') {
						return fieldA.localeCompare(fieldB);
					} else {
						return fieldB.localeCompare(fieldA);
					}
				});
			} else {
				// No search term, use regular sorting
				entries.sort((a, b) => {
					const fieldA = currentSortField === 'english' ? a.english.toLowerCase() : a.ichrolic.toLowerCase();
					const fieldB = currentSortField === 'english' ? b.english.toLowerCase() : b.ichrolic.toLowerCase();

					if (sortDirection === 'asc') {
						return fieldA.localeCompare(fieldB);
					} else {
						return fieldB.localeCompare(fieldA);
					}
				});
			}

			// Display entries
			const isMobile = isMobileView();
			
			// Update desktop view
			if (!isMobile) {
				for (const entry of entries) {
					const row = document.createElement('tr');
					if (entry.isSynonym) {
						row.classList.add('synonym-row');
					}

					const englishCell = document.createElement('td');
					englishCell.textContent = entry.english;
					if (entry.isSynonym) {
						englishCell.textContent += ` (→ ${entry.canonicalForm})`;
					}

					const ichrolicCell = document.createElement('td');
					ichrolicCell.textContent = entry.ichrolic;

					const actionsCell = document.createElement('td');

					// Create delete button
					const deleteButton = document.createElement('button');
					deleteButton.textContent = 'Delete';
					deleteButton.style.backgroundColor = '#ec474f';
					deleteButton.style.marginRight = '5px';
					deleteButton.addEventListener('click', function() {
						if (entry.isSynonym) {
							delete synonyms[entry.english];
						} else {
							delete dictionary[entry.english];
						}
						updateDictionaryTable();
						translateToIchrolic();
					});

					actionsCell.appendChild(deleteButton);

					// Create edit button for primary entries
					if (!entry.isSynonym) {
						const editButton = document.createElement('button');
						editButton.textContent = 'Edit';
						editButton.style.marginLeft = '5px';
						editButton.addEventListener('click', function() {
							// Populate the input fields with the current values
							newEnglishInput.value = entry.english;
							newIchrolicInput.value = entry.ichrolic;

							// Remove the old entry
							delete dictionary[entry.english];

							// Focus on the ichrolic input for editing
							newIchrolicInput.focus();

							updateDictionaryTable();
						});
						actionsCell.appendChild(editButton);
					}

					// Only show "Make primary" button for synonyms
					if (entry.isSynonym) {
						const makePrimaryButton = document.createElement('button');
						makePrimaryButton.textContent = 'Make Primary';
						makePrimaryButton.style.backgroundColor = '#a9bbd0';
						makePrimaryButton.style.marginLeft = '5px';
						makePrimaryButton.addEventListener('click', function() {
							// Get the translation from the canonical form
							const translation = dictionary[entry.canonicalForm];

							// Remove the synonym
							delete synonyms[entry.english];

							// Add as a primary entry
							dictionary[entry.english] = translation;

							updateDictionaryTable();
							translateToIchrolic();
						});

						actionsCell.appendChild(makePrimaryButton);
					}

					row.appendChild(englishCell);
					row.appendChild(ichrolicCell);
					row.appendChild(actionsCell);
					dictionaryBody.appendChild(row);
				}
			} else {
				// Mobile view entries
				for (const entry of entries) {
					const entryDiv = document.createElement('div');
					entryDiv.className = 'mobile-table-entry';
					if (entry.isSynonym) {
						entryDiv.classList.add('synonym-row');
					}
					
					// English row
					const englishRow = document.createElement('div');
					englishRow.className = 'mobile-table-row';
					
					const englishLabel = document.createElement('div');
					englishLabel.className = 'mobile-table-label';
					englishLabel.textContent = 'English:';
					
					const englishValue = document.createElement('div');
					englishValue.className = 'mobile-table-value';
					englishValue.textContent = entry.english;
					if (entry.isSynonym) {
						englishValue.textContent += ` (→ ${entry.canonicalForm})`;
					}
					
					englishRow.appendChild(englishLabel);
					englishRow.appendChild(englishValue);
					entryDiv.appendChild(englishRow);
					
					// Ichrolic row
					const ichrolicRow = document.createElement('div');
					ichrolicRow.className = 'mobile-table-row';
					
					const ichrolicLabel = document.createElement('div');
					ichrolicLabel.className = 'mobile-table-label';
					ichrolicLabel.textContent = 'Ichrolic:';
					
					const ichrolicValue = document.createElement('div');
					ichrolicValue.className = 'mobile-table-value';
					ichrolicValue.textContent = entry.ichrolic;
					
					ichrolicRow.appendChild(ichrolicLabel);
					ichrolicRow.appendChild(ichrolicValue);
					entryDiv.appendChild(ichrolicRow);
					
					// Actions row
					const actionsDiv = document.createElement('div');
					actionsDiv.className = 'mobile-table-actions';
					
					// Create delete button
					const deleteButton = document.createElement('button');
					deleteButton.textContent = 'Delete';
					deleteButton.style.backgroundColor = '#ec474f';
					deleteButton.addEventListener('click', function() {
						if (entry.isSynonym) {
							delete synonyms[entry.english];
						} else {
							delete dictionary[entry.english];
						}
						updateDictionaryTable();
						translateToIchrolic();
					});
					
					actionsDiv.appendChild(deleteButton);
					
					// Create edit button for primary entries
					if (!entry.isSynonym) {
						const editButton = document.createElement('button');
						editButton.textContent = 'Edit';
						editButton.addEventListener('click', function() {
							// Populate the input fields with the current values
							newEnglishInput.value = entry.english;
							newIchrolicInput.value = entry.ichrolic;

							// Remove the old entry
							delete dictionary[entry.english];

							// Focus on the ichrolic input for editing
							newIchrolicInput.focus();

							updateDictionaryTable();
						});
						actionsDiv.appendChild(editButton);
					}
					
					// Only show "Make primary" button for synonyms
					if (entry.isSynonym) {
						const makePrimaryButton = document.createElement('button');
						makePrimaryButton.textContent = 'Make Primary';
						makePrimaryButton.style.backgroundColor = '#a9bbd0';
						makePrimaryButton.addEventListener('click', function() {
							// Get the translation from the canonical form
							const translation = dictionary[entry.canonicalForm];

							// Remove the synonym
							delete synonyms[entry.english];

							// Add as a primary entry
							dictionary[entry.english] = translation;

							updateDictionaryTable();
							translateToIchrolic();
						});

						actionsDiv.appendChild(makePrimaryButton);
					}
					
					entryDiv.appendChild(actionsDiv);
					mobileTable.appendChild(entryDiv);
				}
			}

			// Show/hide appropriate view based on screen size
			if (isMobile) {
				document.getElementById('desktopTable').style.display = 'none';
				document.getElementById('mobileTable').style.display = 'block';
			} else {
				document.getElementById('desktopTable').style.display = 'table';
				document.getElementById('mobileTable').style.display = 'none';
			}

			// Update empty dictionary message visibility
			const emptyDictionary = document.getElementById('emptyDictionary');
			if (entries.length === 0) {
				emptyDictionary.style.display = 'block';
			} else {
				emptyDictionary.style.display = 'none';
			}
		}

		// Function to toggle between direct entry and synonym modes:
		function toggleSynonymMode() {
			isSynonymMode = !isSynonymMode;

			if (isSynonymMode) {
				synonymToggleButton.textContent = "→";
				newIchrolicInput.placeholder = "Synonym for";
				synonymToggleButton.title = "Currently in synonym mode";
			} else {
				synonymToggleButton.textContent = "=";
				newIchrolicInput.placeholder = "Ichrolic translation";
				synonymToggleButton.title = "Currently in direct translation mode";
			}
		}

		// Add dictionary entry function
		function addDictionaryEntry() {
			const english = newEnglishInput.value.trim();
			const ichrolic = newIchrolicInput.value.trim();

			if (english === '') {
				dictionaryStatus.textContent = "English field must be filled.";
				return;
			}

			if (ichrolic === '' && !isSynonymMode) {
				dictionaryStatus.textContent = "Ichrolic translation field must be filled.";
				return;
			}

			if (isSynonymMode) {
				// In synonym mode, add as a synonym for the existing entry
				if (!dictionary.hasOwnProperty(ichrolic)) {
					dictionaryStatus.textContent = `Error: "${ichrolic}" is not in the dictionary as a primary entry.`;
					return;
				}

				// Add as a synonym
				synonyms[english.toLowerCase()] = ichrolic.toLowerCase();
				dictionaryStatus.textContent = `Added "${english}" as a synonym for "${ichrolic}".`;
			} else {
				// In direct translation mode, add as a primary entry
				dictionary[english.toLowerCase()] = ichrolic;
				dictionaryStatus.textContent = `Added "${english}" to the dictionary.`;
			}

			// Clear the input fields
			newEnglishInput.value = '';
			newIchrolicInput.value = '';

			// Update the table and translation
			updateDictionaryTable();
			translateToIchrolic();

			// Clear status message after 3 seconds
			setTimeout(() => {
				dictionaryStatus.textContent = "";
			}, 3000);
		}

		// Automatically load the dictionary when the page loads
		window.addEventListener('DOMContentLoaded', function() {
			loadDefaultDictionary();
		});

		// Function to load the default dictionary from a file in the repo
		function loadDefaultDictionary() {
			fetch('dictionary.json')
				.then(response => {
					if (!response.ok) {
						throw new Error('Failed to load dictionary file. Status: ' + response.status);
					}
					return response.json();
				})
				.then(data => {
					if (data.dictionary && data.synonyms) {
						dictionary = data.dictionary;
						synonyms = data.synonyms;
						updateDictionaryTable();
						translateToIchrolic();
						dictionaryStatus.textContent = "Default dictionary loaded successfully.";
						
						// Clear status message after 3 seconds
						setTimeout(() => {
							dictionaryStatus.textContent = "";
						}, 3000);
					} else {
						throw new Error('Invalid dictionary format in file.');
					}
				})
				.catch(error => {
					console.error('Error loading dictionary:', error);
					dictionaryStatus.textContent = "Error loading dictionary: " + error.message + ". Using empty dictionary.";
					
					// Initialize with empty dictionary if loading fails
					dictionary = {};
					synonyms = {};
					updateDictionaryTable();
				});
		}

		// Function to translate English to Ichrolic
		function translateToIchrolic() {
			const english = englishInput.value.trim();
			if (english === "") {
				ichrolicOutput.value = "";
				return;
			}

			const ignoreDiacritics = ignoreDiacriticsCheckbox.checked;
			const useContractions = useContractionsCheckbox.checked;

			// Keep track of capitalization for each word
			const englishWords = english.split(" ");
			const capitalizationMap = {};

			for (let i = 0; i < englishWords.length; i++) {
				const word = englishWords[i];
				if (word.length > 0) {
					capitalizationMap[i] = word[0] === word[0].toUpperCase();
				}
			}

			// Sort dictionary keys by length (descending) to prioritize longer phrases
			const sortedKeys = Object.keys(dictionary).sort((a, b) =>
				b.split(" ").length - a.split(" ").length
			);

			// Tokenize the English text, preserving punctuation
			const tokens = [];
			let currentWord = "";
			const punctuationChars = [",", ".", "!", "?", ";", ":"];

			for (const c of english) {
				if (c === " ") {
					if (currentWord !== "") {
						tokens.push(currentWord);
						currentWord = "";
					}
					tokens.push(" ");
				} else if (punctuationChars.includes(c)) {
					if (currentWord !== "") {
						tokens.push(currentWord);
						currentWord = "";
					}
					tokens.push(c);
				} else {
					currentWord += c;
				}
			}

			if (currentWord !== "") {
				tokens.push(currentWord);
			}

			// Find multi-word phrases and translate
			let i = 0;
			const result = [];
			const resultToEnglishIndex = {};
			let englishIndex = 0;

			while (i < tokens.length) {
				let foundPhrase = false;

				// Skip spaces
				if (tokens[i] === " ") {
					result.push(" ");
					i++;
					continue;
				}

				// Check if punctuation
				if (tokens[i].length === 1 && punctuationChars.includes(tokens[i])) {
					result.push(tokens[i]);
					i++;
					continue;
				}

				// Try to match multi-word phrases
				for (const key of sortedKeys) {
					if (key.includes(" ")) {  // Multi-word phrase
						const phraseWords = key.split(" ");
						let potentialMatch = true;
						const phraseTokens = [];
						let j = i;

						// Collect tokens that might form the phrase
						for (const word of phraseWords) {
							if (j >= tokens.length || tokens[j] === " " || punctuationChars.includes(tokens[j])) {
								j++;
								continue;
							}

							phraseTokens.push(tokens[j].toLowerCase());
							j++;

							// Skip spaces
							if (j < tokens.length && tokens[j] === " ") {
								j++;
							}
						}

						// Check if we have a match
						if (phraseTokens.length === phraseWords.length) {
							const matchStr = phraseTokens.join(" ");
							if (matchStr.toLowerCase() === key.toLowerCase()) {
								foundPhrase = true;
								result.push(dictionary[key]);

								// Map this result to the English word
								resultToEnglishIndex[result.length - 1] = englishIndex;

								// Skip the matched tokens
								for (let k = 0; k < phraseWords.length * 2 - 1; k++) {
									if (i < tokens.length) {
										if (tokens[i] !== " " && !punctuationChars.includes(tokens[i])) {
											englishIndex++;
										}
										i++;
									}
								}

								break;
							}
						}
					}
				}

				// If no phrase match, process as regular word
				if (!foundPhrase && i < tokens.length) {
					const token = tokens[i];

					// Skip spaces
					if (token === " ") {
						result.push(" ");
						i++;
						continue;
					}

					// Process punctuation
					if (token.length === 1 && punctuationChars.includes(token)) {
						result.push(token);
						i++;
						continue;
					}

					// Process regular word
					const cleanWord = token.toLowerCase();
					const canonicalWord = getCanonicalForm(cleanWord);

					if (dictionary.hasOwnProperty(canonicalWord)) {
						result.push(dictionary[canonicalWord]);
						resultToEnglishIndex[result.length - 1] = englishIndex;
					} else {
						result.push("[" + token + "]");
						resultToEnglishIndex[result.length - 1] = englishIndex;
					}

					englishIndex++;
					i++;
				}
			}

			// Join the result, properly handling spaces and punctuation
			let finalResult = "";
			for (let j = 0; j < result.length; j++) {
				const token = result[j];

				if (token === " ") {
					finalResult += " ";
				} else if (token.length === 1 && punctuationChars.includes(token)) {
					// Don't add space before punctuation
					finalResult += token;
				} else {
					// Add space before words if needed
					if (j > 0 && result[j-1] !== " " && !(result[j-1].length === 1 && punctuationChars.includes(result[j-1]))) {
						finalResult += " ";
					}
					finalResult += token;
				}
			}

			let ichrolic = finalResult.trim();

			// Apply synonym handling for phrases
			for (const synonymKey in synonyms) {
				if (synonymKey.includes(" ")) {
					const canonicalKey = synonyms[synonymKey];
					if (dictionary.hasOwnProperty(canonicalKey)) {
						const pattern = "\\[" + synonymKey.replace(/ /g, "\\] \\[") + "\\]";
						const regex = new RegExp(pattern, "g");
						const matches = ichrolic.match(regex);
						if (matches && matches.length > 0) {
							for (const match of matches) {
								ichrolic = ichrolic.replace(match, dictionary[canonicalKey]);
							}
						}
					}
				}
			}

			// Apply contractions if the option is enabled
			if (useContractions) {
				ichrolic = applyContractions(ichrolic, capitalizationMap, resultToEnglishIndex);
			}

			// Remove diacritics if the option is enabled
			if (ignoreDiacritics) {
				ichrolic = removeDiacritics(ichrolic);
			}

			ichrolicOutput.value = ichrolic;
		}

		// Function to get canonical form from synonyms
		function getCanonicalForm(word) {
			const lowercaseWord = word.toLowerCase();

			// Check if word already exists in main dictionary
			if (dictionary.hasOwnProperty(lowercaseWord)) {
				return lowercaseWord;
			}

			// Check if word is a synonym
			if (synonyms.hasOwnProperty(lowercaseWord)) {
				return synonyms[lowercaseWord];
			}

			return lowercaseWord;  // Return original if not found
		}

		// Function to apply contractions
		function applyContractions(text, capitalizationMap, resultToEnglishIndex) {
			if (!useContractionsCheckbox.checked) {
				return text;
			}

			// Split text by terminal punctuation
			const terminalPunctuation = [".", "!", "?", ","];
			const segments = [];
			let currentSegment = "";

			for (let i = 0; i < text.length; i++) {
				const char = text[i];
				currentSegment += char;

				if (terminalPunctuation.includes(char)) {
					segments.push(currentSegment);
					currentSegment = "";
				}
			}

			// Add any remaining text
			if (currentSegment !== "") {
				segments.push(currentSegment);
			}

			// Process each segment separately
			const processedSegments = segments.map(segment =>
				processSegmentContractions(segment, capitalizationMap, resultToEnglishIndex)
			);

			// Join the segments
			return processedSegments.join(" ").trim();
		}

		// Process contractions within a single segment
		function processSegmentContractions(segment, capitalizationMap, resultToEnglishIndex) {
			// List of mergable words
			const mergableWords = [
				"ali",
				"ìkè"
			];

			// Prefixes that should always combine with the following word
			const prefixes = [
				"èden",
				"al-",
				"yana"
			];

			// Suffixes that should always combine with the preceding word
			const suffixes = [
				"íka",
				"yuhni"
			];

			const words = segment.trim().split(" ");
			const result = [];
			let i = 0;
			const skipIndices = new Set();

			while (i < words.length) {
				// Skip if this index has been marked for skipping
				if (skipIndices.has(i)) {
					i++;
					continue;
				}

				const currentWord = words[i];
				let combined = false;

				// Check for prefixes
				if (i < words.length - 1 && prefixes.includes(currentWord.toLowerCase())) {
					const nextWord = words[i+1];

					// Check if the corresponding English word is capitalized
					let isCapitalized = false;
					if (resultToEnglishIndex.hasOwnProperty(i)) {
						isCapitalized = capitalizationMap[resultToEnglishIndex[i]] || false;
					}

					result.push(mergeWords(currentWord, nextWord, isCapitalized, false));
					skipIndices.add(i + 1);
					i++;
					combined = true;
				}

				// Check for suffixes on the previous word
				if (!combined && suffixes.includes(currentWord.toLowerCase()) && i > 0 && result.length > 0) {
					const prevWord = result[result.length - 1];

					// Check if the corresponding English word is capitalized
					let isCapitalized = false;
					if (resultToEnglishIndex.hasOwnProperty(i - 1)) {
						isCapitalized = capitalizationMap[resultToEnglishIndex[i - 1]] || false;
					}

					result.pop();
					result.push(mergeWords(prevWord, currentWord, isCapitalized, false));
					combined = true;
				}

				// Check if current word is a mergable word
				if (!combined && mergableWords.includes(currentWord.toLowerCase())) {
					// Check if we can combine with previous word
					if (i > 0 && result.length > 0) {
						const prevWord = result[result.length - 1];

						// Check if the corresponding English word is capitalized
						let isCapitalized = false;
						if (resultToEnglishIndex.hasOwnProperty(i - 1)) {
							isCapitalized = capitalizationMap[resultToEnglishIndex[i - 1]] || false;
						}

						// Remove the last added word and combine
						result.pop();
						result.push(mergeWords(prevWord, currentWord, isCapitalized));
						combined = true;
					}

					// Check if we can combine with next word (if not already combined)
					if (!combined && i < words.length - 1) {
						const nextWord = words[i+1];

						// Check if the corresponding English word is capitalized
						let isCapitalized = false;
						if (resultToEnglishIndex.hasOwnProperty(i)) {
							isCapitalized = capitalizationMap[resultToEnglishIndex[i]] || false;
						}

						// Combine and skip the next word
						result.push(mergeWords(currentWord, nextWord, isCapitalized));
						skipIndices.add(i + 1);
						i++;
						combined = true;
					}

					// If no combination happened, add the word as is
					if (!combined) {
						result.push(currentWord);
					}
				} else {
					// Not a mergable word, add as is if not already combined
					if (!combined) {
						result.push(currentWord);
					}
				}

				i++;
			}

			return result.join(" ");
		}

		// Helper function to merge words handling vowel overrides
		function mergeWords(word1, word2, isFirstCapitalized, atJunction = true) {
			// Check if we need to handle duplicate letters at junction
			if (atJunction && word1.length > 0 && word2.length > 0 &&
				word1[word1.length - 1].toLowerCase() === word2[0].toLowerCase()) {
				return word1 + word2.substring(1);
			}

			// Get base vowels (without diacritics)
			const vowels = ["a", "e", "i", "o", "u"];
			const vowelMap = {
				"a": ["á", "à", "â", "ä"],
				"e": ["é", "è", "ê", "ë"],
				"i": ["í", "ì", "î", "ï"],
				"o": ["ó", "ò", "ô", "ö"],
				"u": ["ú", "ù", "û", "ü"]
			};

			// Create a reverse lookup from accented vowel to base vowel
			const accentedToBase = {};
			for (const base in vowelMap) {
				for (const accented of vowelMap[base]) {
					accentedToBase[accented] = base;
				}
			}

			// Check junction point for vowel clash
			if (word1.length > 0 && word2.length > 0) {
				const lastChar = word1[word1.length - 1].toLowerCase();
				const firstChar = word2[0].toLowerCase();

				// Check if there's a vowel clash
				const isLastVowel = vowels.includes(lastChar) || accentedToBase.hasOwnProperty(lastChar);
				const isFirstVowel = vowels.includes(firstChar) || accentedToBase.hasOwnProperty(firstChar);

				if (isLastVowel && isFirstVowel) {
					// Determine which vowel to use based on priority and English capitalization
					let useSecondVowel = true;

					// If the first word corresponds to a capitalized English word, preserve its vowel
					if (isFirstCapitalized) {
						useSecondVowel = false;
					}

					if (useSecondVowel) {
						// Use the second word's vowel (possibly with diacritics)
						return word1.substring(0, word1.length - 1) + word2;
					} else {
						// Use the first word's vowel (possibly with diacritics)
						return word1 + word2.substring(1);
					}
				}
			}

			if (word1.length > 0 && word2.length > 0 &&
				word1[word1.length - 1].toLowerCase() === word2[0].toLowerCase()) {
				// Remove the duplicate letter
				return word1 + word2.substring(1);
			}

			return word1 + word2;
		}

		// Function to remove diacritics from Ichrolic text
		function removeDiacritics(text) {
			if (!text) return text;

			// Map of characters with diacritics to their base form
			const diacriticMap = {
				"í": "i", "é": "e", "á": "a", "ó": "o", "ú": "u",
				"ì": "i", "è": "e", "à": "a", "ò": "o", "ù": "u",
				"î": "i", "ê": "e", "â": "a", "ô": "o", "û": "u",
				"ï": "i", "ë": "e", "ä": "a", "ö": "o", "ü": "u"
			};

			let result = text;
			for (const diacritic in diacriticMap) {
				result = result.split(diacritic).join(diacriticMap[diacritic]);
			}

			return result;
		}

		// Dictionary update functionality
		async function handleDictionaryUpdate() {
			if (!githubToken || !currentUser) {
				alert('Please sign in first to update the dictionary');
				return;
			}

			// Show loading state
			saveDictionaryButton.classList.add('loading');
			saveDictionaryButton.disabled = true;
			dictionaryStatus.textContent = "Checking for changes...";

			try {
				// Fetch current dictionary from GitHub
				const githubDict = await fetchCurrentDictionary();
				const githubContent = JSON.parse(atob(githubDict.content));

				// Prepare local dictionary for comparison (exact same format as GitHub)
				const localContent = {
					dictionary: {},
					synonyms: {}
				};

				// Sort local dictionaries exactly like GitHub version
				const sortedKeys = Object.keys(dictionary).sort();
				for (const key of sortedKeys) {
					localContent.dictionary[key] = dictionary[key];
				}

				const sortedSynKeys = Object.keys(synonyms).sort();
				for (const key of sortedSynKeys) {
					localContent.synonyms[key] = synonyms[key];
				}

				// Normalize both for comparison (remove any formatting differences)
				const normalizeForComparison = (obj) => JSON.stringify(obj, Object.keys(obj).sort());
				
				const githubNormalized = normalizeForComparison(githubContent);
				const localNormalized = normalizeForComparison(localContent);

				console.log('Comparing dictionaries...');
				console.log('GitHub keys:', Object.keys(githubContent.dictionary || {}).length, 'dictionary,', Object.keys(githubContent.synonyms || {}).length, 'synonyms');
				console.log('Local keys:', Object.keys(localContent.dictionary).length, 'dictionary,', Object.keys(localContent.synonyms).length, 'synonyms');

				if (githubNormalized === localNormalized) {
					dictionaryStatus.textContent = "Dictionary is already up to date! No changes detected.";
					setTimeout(() => {
						dictionaryStatus.textContent = "";
					}, 3000);
					return;
				}

				// Dictionaries are different, update GitHub
				dictionaryStatus.textContent = "Updating dictionary on GitHub...";
				
				const updateResult = await updateDictionaryOnGitHub(localContent, githubDict.sha);

				dictionaryStatus.textContent = `Dictionary updated successfully! Commit: ${updateResult.commit.sha.substring(0, 7)}`;
				setTimeout(() => {
					dictionaryStatus.textContent = "";
				}, 5000);

			} catch (error) {
				console.error('Dictionary update error:', error);
				dictionaryStatus.textContent = `Update failed: ${error.message}`;
				setTimeout(() => {
					dictionaryStatus.textContent = "";
				}, 5000);
			} finally {
				saveDictionaryButton.classList.remove('loading');
				saveDictionaryButton.disabled = false;
			}
		}

		// Modified save dictionary function to handle both modes
		function saveDictionary() {
			if (isDeveloperMode && githubToken) {
				// Developer mode with GitHub token - update repository
				handleDictionaryUpdate();
			} else {
				// Normal mode - download file
				saveLocalDictionary();
			}
		}

		// Renamed original save function
		function saveLocalDictionary() {
			try {
				// Create sorted copies of the dictionaries
				const sortedDictionary = {};
				const sortedKeys = Object.keys(dictionary).sort();
				for (const key of sortedKeys) {
					sortedDictionary[key] = dictionary[key];
				}

				const sortedSynonyms = {};
				const sortedSynKeys = Object.keys(synonyms).sort();
				for (const key of sortedSynKeys) {
					sortedSynonyms[key] = synonyms[key];
				}

				// Create the data structure to save
				const saveData = {
					dictionary: sortedDictionary,
					synonyms: sortedSynonyms
				};

				// Convert to JSON
				const jsonString = JSON.stringify(saveData, null, 2);

				// Create a blob and download link
				const blob = new Blob([jsonString], {type: 'application/json'});
				const url = URL.createObjectURL(blob);

				// Create a temporary download link
				const downloadLink = document.createElement('a');
				downloadLink.href = url;
				downloadLink.download = 'ichrolic_dictionary.json';

				// Append to body, click, and remove
				document.body.appendChild(downloadLink);
				downloadLink.click();
				document.body.removeChild(downloadLink);

				// Release the object URL
				URL.revokeObjectURL(url);

				dictionaryStatus.textContent = "Dictionary saved successfully to file.";

				// Clear status message after 3 seconds
				setTimeout(() => {
					dictionaryStatus.textContent = "";
				}, 3000);
			} catch (error) {
				dictionaryStatus.textContent = "Error saving dictionary: " + error.message;
			}
		}

		// Toggle dictionary table visibility
		function toggleDictionaryTable() {
			if (dictionaryTable.style.display === "none") {
				dictionaryTable.style.display = "block";
				updateDictionaryTable();
			} else {
				dictionaryTable.style.display = "none";
			}
		}

		// Dictionary sorting parameters
		let currentSortField = 'english'; // Default sort by English
		let sortDirection = 'asc'; // Default sort direction

		// Function to toggle sort direction and field
		function sortDictionary(field) {
			if (currentSortField === field) {
				// Toggle direction if clicking same field
				sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
			} else {
				// Set new field and reset direction to ascending
				currentSortField = field;
				sortDirection = 'asc';
			}

			updateSortIndicators();
			updateDictionaryTable();
		}

		// Function to update sort indicators in table headers
		function updateSortIndicators() {
			// Update the English header
			englishHeader.innerHTML = "English";
			if (currentSortField === 'english') {
				englishHeader.innerHTML += ` <span class="sort-indicator">${sortDirection === 'asc' ? '▲' : '▼'}</span>`;
			}

			// Update the Ichrolic header
			ichrolicHeader.innerHTML = "Ichrolic";
			if (currentSortField === 'ichrolic') {
				ichrolicHeader.innerHTML += ` <span class="sort-indicator">${sortDirection === 'asc' ? '▲' : '▼'}</span>`;
			}
		}
	</script>
</body>
</html>
